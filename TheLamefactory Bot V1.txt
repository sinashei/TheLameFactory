// This Pine Scriptâ„¢ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
//@version=5
strategy ('TheLameFactory v1.0 by @TheLame', 'TheLameFactory',  overlay = true, calc_on_every_tick = false, calc_on_order_fills = false, default_qty_type = strategy.percent_of_equity, commission_value = 0.02,pyramiding = 1)
version = "1.1.1"

//â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> General Definitions & Setting Management<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
//-----------------------------------------------------------------------------}
//                                Libraries
//-----------------------------------------------------------------------------{
//import HeWhoMustNotBeNamed/enhanced_ta/8 as enhanced_ta
//import daviddtech/DivergencesLibrary/1 as divergence
//import sp2432/Debug_Window_Library/5 as console

//-----------------------------------------------------------------------------}
//                              General Lengths
//-----------------------------------------------------------------------------{
len1 = 9
len2 = 21
len3 = 55
len4 = 100
len5 = 200

//-----------------------------------------------------------------------------}
//                             General Variables
//-----------------------------------------------------------------------------{
_vwap_on        = false
_adx_on         = false
_maxtrades_on   = false
_rsi_on         = false
_mfi_on         = false
_flat_on        = false
_plot_on        = true

//-----------------------------------------------------------------------------}
//                                 Groups
//-----------------------------------------------------------------------------{
versionGp                   = 'Welcome'
tradetypeGp                 = 'ðŸ“ŠTrade TypeðŸ“ˆ'
tpslGp                      = 'ðŸ’° TP / SL Type'
fixperTpSlGp                = 'ðŸ’° Fixed Percent - Take Profit / Stoploss'
pipsTpSlGp                  = 'ðŸ’° PIPS - Take Profit / Stoploss'
hhllTpSlGp                  = 'ðŸ’° HH/LL - Take Profit / Stoploss'
modeGp                      = 'ðŸ’ª MODE'
atrSlGp                     = 'ðŸ›‘ ATR Stoploss'
atrlengGlGp                 = 'ATR Global Settings'
trailSlGp                   = 'ðŸ’Ž Trailing Stop'
riskmanagementGp            = 'ðŸ¥¶ Risk Management'
sizeandlevmangmentGp        = 'ðŸ¥¶ Position Size & Leverage Management'
rrprotectionGp              = 'ðŸ¥¶ Risk to Reward Protection'
multiProfitGp               = 'ðŸ’° Multiple Take Profit Levels'
tradevarGp                  = 'âš™ï¸ Trade variables'

//-----------------------------------------------------------------------------}
//                                Tooltips
//-----------------------------------------------------------------------------{
thelamefactoryVersionTip    = 'Choose the Version of the Bot'
LongTradesTip               = 'Turn on/off long trades. Perhaps you are overall bearish and wish to exempt long trades on this asset'
ShortTradesTip              = 'Turn on/off short trades. Perhaps you are overall bullish and wish to exempt long trades on this asset'
typeOfTPTip                 = 'Choose type of Take Profit'
typeOfExitTip               = 'Choose type of Exit'
atrLenTip                   = 'Length of the period for the ATR to average'
trailStopTip                = 'Turns on/off the ATR trailing stop exit method'
trailStopSizeTip            = 'The ATR multiplier for ATR-based trailing stop. Higher number yields a higher volatility based risk adjustment from the swing low'
trailSourceTip              = 'The price source for calculating ATR trailing stop'
rrExitTip                   = 'Reward (target price) that must hit in order to trigger the trail expressed as a decimal. eg. 0.5 = 50% to target.'
setMaxDrawdownTip           = 'Enables max drawdown protection. Enabling this will stop the bot if the overall strategy drawdown drops below the defines'
i_firstShowTip              = 'This will just add a reference line to the graph and will not be detect by backtesting. In This is for reference only'
i_leverageBlockTip          = 'This will block any trades where the leverage line is below/above the Stop loss'
maxpercentTip               = 'If Stoploss is above X% on dynamic SL \n Do not enter = It will not take trade. \n Use Percentage Instead = It'
useLimitTip                 = 'Turns on/off the limit exit method. eg: using trail and not setting a limit exit. Must use trail, or strategy has no exit crite'
FLIPTip                     = 'Allows a reversal trade. eg. flipping short from a long pos. False will isolate trades from one another, while true allows an oppo:'

RnRTip                      = 'This sets your risk to reward as a multiple. 1 is stop/limit equal distance from entry'
RiskMTip                    = 'Multiplier as a function of the ATR value projected from the calculated swing high/low. This allows for a buffer for your stop pla'
swinglookbackTip            = 'This is your swing lookback. The the number of bars within the period calculated for lowest or highest value to establish'
maxPercDdTip                = 'Risk appetite. Every strategy sees downside. This is how much your stomach could allow the bot to lose if you let it run. Strategy stops taking trades below this level'
maTypelTip                  = 'Sets the moving average type for the first MA'
maType2Tip                  = 'Sets the maLength1Tipmoving averagetypefor second MA'
maLength1Tip                = 'Sets the length for the first MA. (it is likely best to keep MAl '
maLength2Tip                = 'Sets the length for the second MA.Is Likely best to keep 422 length greater Man 02, or a may result in sposte trade'
drawEntryTip                = 'Shows the trade entry level'
exitLvlTip                  = 'Shows level the level that the trailing stop is triggered'
useTimeFilterTip            = 'Turns on/off time session filter'
timeSessionTip              = 'Time session to ignore trades (useful for ignoring trades during times you don\'t want to trade.eg. Markets are slow for a'
startTimeTip                = ''
endTimeTip                  = 'End date & time to stop searching for setups for testing beginning new bot. eg.'
rrexplained                 = 'R:R (Risk to Reward) is used by default for ATR and HH/LL'


//â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
// >>>>>>>>>>>>>>>>>>>> USER INPUT <<<<<<<<<<<<<<<<<<<<<<<<
//â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
//-----------------------------------------------------------------------------}
//                              Bot Version
//-----------------------------------------------------------------------------{
_thelamefactoryVersion  = input.string(defval   = version,              title = 'TheLameFactory Version',                           group = versionGp,          tooltip = thelamefactoryVersionTip,     options = [version])

//-----------------------------------------------------------------------------}
//                             ðŸ“ŠTrade TypeðŸ“ˆ
//-----------------------------------------------------------------------------{
longTrades              = input.bool(defval     = true,                 title = 'Long Trades',                                      group = tradetypeGp,    tooltip = LongTradesTip) 
shortTrades             = input.bool(defval     = true,                 title = 'Short Trades',                                     group = tradetypeGp,    tooltip = ShortTradesTip) 

//-----------------------------------------------------------------------------}
//                         ðŸ’°Take Profit & Stop LossðŸ’°
//-----------------------------------------------------------------------------{
//choiceStrategy = input(title-"Type of Exit / Entry", defval="Enter New Trade Only if NO running Trades", options= ("Enter New Trade and Exit 
typeOfTP                = input.string(defval   = 'Fixed Percent',      title='Type of Take Profit',                                group = tpslGp,             tooltip = typeOfTPTip,      options=['Fixed Percent', 'R:R', 'PIPS', 'Custom'])
typeOfExit              = input.string(defval   = 'Fixed Percent',      title='Type of Stoploss',                                   group = tpslGp,             tooltip = typeOfExitTip,    options=['Fixed Percent', 'ATR', 'Keltner', 'MA #1', 'MA #2', 'Bollinger Bands', 'Donchian Channel', 'PIPS', 'HH/LL', 'Custom']) 
enablepercent           = typeOfExit            == 'Fixed Percent'  ?   true: false

//ðŸ’° Fixed Percent - Take Profit / Stoploss
StopPerLong             = input.float(defval    = 1.6,  step = 0.1,     title='Stop loss Long %',                                   group = fixperTpSlGp) 
TakePerLong             = input.float(defval    = 2.8,  step = 0.1,     title='Take Profit Long %',                                 group = fixperTpSlGp)
stopPer                 = input.float(defval    = 1.6,  step = 0.1,     title='Stop loss Short %',                                  group = fixperTpSlGp)
takePer                 = input.float(defval    = 2.8,  step = 0.1,     title='Take Profit Short %',                                group = fixperTpSlGp)

//ðŸ’° PIPS - Take Profit / Stoploss
stopPIPSLong            = input.int(defval      = 100,  step = 1,       title='Stop loss Long PIPS',                                group = pipsTpSlGp) 
takePIPSLong            = input.int(defval      = 200,  step = 1,       title='Take Profit Long PIPS',                              group = pipsTpSlGp) 
stopPIPS                = input.int(defval      = 100,  step = 1,       title='Stop loss Short PIPS',                               group = pipsTpSlGp) 
takePIPS                = input.int(defval      = 200,  step = 1,       title='Take Profit Short PIPS',                             group = pipsTpSlGp)

//ðŸ’° HH/LL - Take Profit / Stoploss
highLen                 = input.int(defval      = 50,   minval = 2,     title='Highest High Lookback',                              group = hhllTpSlGp) 
loLen                   = input.int(defval      = 60,   minval = 2,     title='Highest High Lookback',                              group = hhllTpSlGp)  
enablelowhigh           = typeOfExit            ==      'HH/LL' ?       true: false

profitfactorlong        = input.float(defval    = 2,    step = 0.1,     title='Profit factor Long (Risk to Reward)',                group = hhllTpSlGp)
profitfactorshort       = input.float(defval    = 2,    step = 0.1,     title='Profit factor Short (Risk to Reward)',               group = hhllTpSlGp)
enableatr               = typeOfExit            ==      'ATR'        ?  true: false

//-----------------------------------------------------------------------------}
//                                   ðŸ’ªMODEðŸ’ª
//-----------------------------------------------------------------------------{
hedge_mode              = input(defval          = false,                title= 'hedge Mode',                                        group = modeGp) 
early_mode              = input(defval          = false,                title= 'Early Exit Mode',                                   group = modeGp)  
dca_mode                = input(defval          = false,                title= 'Early Exit Mode',                                   group = modeGp)  
pyramiding_mode         = input(defval          = false,                 title= 'Pyramiding Mode',                                  group = modeGp) 

//-----------------------------------------------------------------------------}
//                               ðŸ›‘ATR StoplossðŸ›‘
//-----------------------------------------------------------------------------{
RiskM                   = input.float(defval    = 1.0,  step = 0.1,     title='ATR Multiplier For Stoploss',                        group = atrSlGp) 
atrType                 = input.string(defval   = 'Source',             title='ATR Source',                                         group = atrSlGp,                options =[ 'Swing Hich/low', 'Source']) 
atr_srcUpper            = input(defval          = close,                title='Source Innner ATR Stoploss',                         group = atrSlGp) 
atr_srcLower            = input(defval          = close,                title='Source lower ATR Stoploss',                          group = atrSlGp) 
swinglookback           = input(defval          = 14,                   title='ATR Swing lookback',                                 group = atrSlGp) 

//ATR Global Settings
atrLen                  = input.int(defval      = 14,                   title = 'ATR length',                                       group = atrlengGlGp,            tooltip=atrLenTip) 

//-----------------------------------------------------------------------------}
//                               ðŸ’ŽTrailing StopðŸ’Ž
//-----------------------------------------------------------------------------{
trailStop               = input.bool(defval     = false,                title = 'Use ATR Trailing Stop',                            group = trailSlGp,              tooltip = trailStopTip) 
trailStopSize           = input.float(defval    = 3.0,  step=0.1,       title='ATR Trailing Stop Multiplier',                       group = trailSlGp,              tooltip = trailStopSizeTip) 

trailSource             = input.string(defval   = 'Close',              title = 'ATR Trailing Stop Source',                         group = trailSlGp,              tooltip = trailSourceTip,       options=['High/low', 'Close', 'Open', 'Keltner', 'Bollinger Bands', 'Donchian Channel'])
activetrail             = input.string(defval   = 'Instant',            title='Activate Trailing?',                                 group=trailSlGp,                options = ['Instant', 'After Hit Threshold %', 'After HIT TP1', 'After HIT TP2']) 

trailProfit             = input.bool(defval     = false,                title = 'Use ATR Trailing Profit',                          group = trailSlGp) 
trailStop               := trailProfit          ? true      : trailStop

rrExit2                 = input.float(defval    = 15,                   title = 'Trigger Trailing Threshold & of Total TP',         group = trailSlGp,              tooltip = rrExitTip) / 100

//-----------------------------------------------------------------------------}
//                               ðŸ¥¶Risk ManagementðŸ¥¶
//-----------------------------------------------------------------------------{
setMaxDrawdown              = input.bool(defval = false,                title = 'Set Max Total DrawDown',                           group = riskmanagementGp,       tooltip=setMaxDrawdownTip)
maxPercDd                   = input.int(defval  = 20,                   title = 'Max Drawdown (%)',                                 group = riskmanagementGp,       tooltip=maxPercDdTip)

max_intraday_loss_activate  = input.bool(defval = false,                title = 'Set Max Intraday Loss',                            group = riskmanagementGp) 
max_intraday_loss           = input.int(defval  = 20,                   title = 'Max Intraday Loss (%)',                            group = riskmanagementGp)

max_cons_loss_days_activate = input.bool(defval = false,                title = 'Set Max Consecutive Days with Losses',             group = riskmanagementGp)
max_cons_loss_days          = input.int(defval  = 20,                   title = 'Max Consecutive Days with Losses',                 group = riskmanagementGp)


slbuffer_long               = input.float(defval = 0.0,                 title='Stop Loss Buffer - Long ',                           group = riskmanagementGp)
slbuffer_short              = input.float(defval = 0.0,                 title='Stop Loss Buffer - Short ',                          group = riskmanagementGp)

marginCal                   = input.string(defval= 'Manual',            title = 'Position Size (BETA)',                             group = sizeandlevmangmentGp,   options=['Manual', 'Kelly Ratio', 'Dynamic Algo'])
//??? _risk_da_qty_1
_risk_source_input          = input.string(defval= 'close',             title = 'DA Source',                                        group = sizeandlevmangmentGp,   options=['close', 'volume', 'MA 5', 'MA 25', 'MACD', 'volume MA']) 
_risk_da_qty_1              = input.float(defval = 1.,  step = 0.1,     title = 'DA Multi 1',   inline = "daqty" ,                  group = sizeandlevmangmentGp) 
_risk_da_qty_2              = input.float(defval = 1.,  step = 0.1,     title = 'DA Multi 2',   inline = "daqty" ,                  group = sizeandlevmangmentGp) 
_risk_da_qty_3              = input.float(defval = 1.,  step = 0.1,     title = 'DA Multi 3',   inline = "daqty" ,                  group = sizeandlevmangmentGp) 

///??? math.pow or math. pow?
g(v, p)                     => math.round(v * math.pow(10, p)) / math. pow(10   ,   p) 

risk                        = input.float(defval = 100, step=0.5,       title = '% of Portfolio',     minval=1, maxval=100,         group = sizeandlevmangmentGp) 
leverage                    = input(defval       = 1,                   title ='Leverage',                                          group = sizeandlevmangmentGp) 
_net_qty                    = g((strategy.equity * leverage / open) * (risk / 100)  ,   4)

//Leverage Risk Management

i_firstShow                 = input.bool(defval = false,                title = 'Show Liquadation line (BETA)',                     group = sizeandlevmangmentGp,       tooltip = i_firstShowTip) 
i_leverageBlock             = input.bool(defval = false,                title = 'Block Trades if Liquadation is before SL (BETA)',  group = sizeandlevmangmentGp,       tooltip = i_leverageBlockTip)

i_firstLeverage             = leverage 
i_Maintenance               = input.float(defval = 0.5,                 title = 'Maintenance Margin Rate',                          group = sizeandlevmangmentGp) 

//-----------------------------------------------------------------------------}
//                                ðŸ¥¶Risk to RewardðŸ¥¶
//-----------------------------------------------------------------------------{
activate_minrr              = input.bool(defval     = false,            title = "Activate Threshold Risk:Reward?",                  group = rrprotectionGp) 
minrr                       = input.float(defval    = 1.0,              title = "Threshold Risk:Reward",                            group = rrprotectionGp) 
activate_maxpercent         = input.bool(defval     = false,            title = "Activate Max 9",                                   group = rrprotectionGp) 
maxpercent_out              = input.string(defval   = 'Do not enter',   title = 'What if threshold breaks ?',                       group = rrprotectionGp,             options=['Do not enter', 'Use Percentage Instead']) 
maxpercent                  = input.float(defval    = 1.0,  step=0.1,   title = 'Threshold Max % SL',                               group = rrprotectionGp,             tooltip = maxpercentTip) 

RnRShort                    = profitfactorshort 
RnRLong                     = profitfactorlong 


multiProfit                 = input.bool(defval     = false,            title = 'Take Multi Profit X3',                             group = multiProfitGp) 
//??? no where the levels have been used!
multiProfitStep1            = input.int(defval      = 33,               title = '% to take at TP1',     inline="tp1",               group = multiProfitGp)
multiProfitStep2            = input.int(defval      = 33,               title = '% to take at TP2',     inline="tp2",               group = multiProfitGp) 
multiProfitStep3            = input.int(defval      = 100,              title = '% to take at TP3',     inline="tp3",               group = multiProfitGp) 

multiProfitStep1Perc        = input.int(defval      = 33,               title = 'Level 1',              inline="tp1",               group = multiProfitGp) 
multiProfitStep2Perc        = input.int(defval      = 66,               title = 'Level 2',              inline="tp2",               group = multiProfitGp) 
multiProfitStep3Perc        = input.int(defval      = 100,              title = 'Level 3',              inline="tp3",               group = multiProfitGp) 

rrExit                      = activetrail == "Instant" ? 0 : activetrail == "After Hit Threshold %" ? rrExit2 : activetrail == "After Hit TP 1" ? multiProfitStep1Perc/100 : activetrail == "After Hit TP 2" ? multiProfitStep2Perc/100 : 0
    
levels_ok                   = (multiProfitStep1Perc <= multiProfitStep2Perc) and (multiProfitStep2Perc <= multiProfitStep3Perc) 

//-----------------------------------------------------------------------------}
//                                âš™ï¸Trade variablesâš™ï¸
//-----------------------------------------------------------------------------{
_repaint                    = input.bool(defval     = false,            title = 'Enable Repainting?',                               group = tradevarGp) 
useLimit                    = input.bool(defval     = true,             title = 'Use Limit exit',                                   group = tradevarGp,                 tooltip = useLimitTip) 
FLIP                        = input.bool(defval     = true,             title = 'Allow Reversal Trades',                            group = tradevarGp,                 tooltip = FLIPTip)
closereverse                = input.bool(defval     = true,             title = 'Close trade on reverse strateav',                  group = tradevarGp)
_getindirect                = input.bool(defval     = false,            title = 'Wait for confirmation of new entry on reversal',   group = tradevarGp)
waitforconfirmed            = input.bool(defval     = true,             title = 'Wait for confirmed?',                              group = tradevarGp)


//-----------------------------------------------------------------------------}
//                                ðŸ“ˆ MA STRATEGY ðŸ“ˆ
//-----------------------------------------------------------------------------{
_useMA = input.string('Off', "Use Moving Averages? ", group='ðŸ“ˆ MA Strategy Settings ðŸ“ˆ', tooltip=maTypelTip, options=['Off', 'Close over/under MA5', 'Ordered MA1,MA2,MA3,MA4.MAS', 'Strict Close over/under MA5', 'Tripple MA MA1,MA2,MA5'])

tredreversal = input.bool(false, title='Reverse All?', group='ðŸ“ˆ MA Strateov Settings ðŸ“ˆ')

reversalall = input.bool(false, 'Reverse all?', group='ðŸ“ˆ MA Strateov Settings ðŸ“ˆ')
boolmaLength1 = input.bool(true, 'MA #1', group='ðŸ“ˆ MA Strateov Settings ðŸ“ˆ', inline='1')
boolmaLength2 = input.bool(true, 'MA #2', group='ðŸ“ˆ MA Strateov Settings ðŸ“ˆ', inline='2')
boolmaLength3 = input.bool(false, 'MA #3', group='ðŸ“ˆ MA Strateov Settings ðŸ“ˆ', inline='3')
boolmaLength4 = input.bool(false, 'MA #4', group='ðŸ“ˆ MA Strateov Settings ðŸ“ˆ', inline='4')
boolmaLength5 = input.bool(false, 'MA #5', group='ðŸ“ˆ MA Strateov Settings ðŸ“ˆ', inline='5')
boolhmabar = input.bool(false, 'HMA BAR', group='ðŸ“ˆ MA Strateov Settings ðŸ“ˆ', inline='6')

maType1 = input.string('FMA', 'MA Type#1', group='ðŸ“ˆ MA Strateov Settings ðŸ“ˆ', inline='1', tooltip=maTypelTip, options=['FMA','HFMA','SMA','HMA','WMA','DEMA','VWMA','VWAP','T3'])
maType2 = input.string('FMA', 'MA Type#2', group='ðŸ“ˆ MA Strateov Settings ðŸ“ˆ', inline='2', tooltip=maType2Tip, options=['FMA','HFMA','SMA','HMA','WMA','DEMA','VWMA','VWAP','T3'])
maType3 = input.string('FMA', 'MA Type#3', group='ðŸ“ˆ MA Strateov Settings ðŸ“ˆ', inline='3', tooltip=maTypelTip, options=['FMA','HFMA','SMA','HMA','WMA','DEMA','VWMA','VWAP','T3'])
maType4 = input.string('FMA', 'MA Type#4', group='ðŸ“ˆ MA Strateov Settings ðŸ“ˆ', inline='4', tooltip=maType2Tip, options=['FMA','HFMA','SMA','HMA','WMA','DEMA','VWMA','VWAP','T3'])
maType5 = input.string('FMA', 'MA Type#5', group='ðŸ“ˆ MA Strateov Settings ðŸ“ˆ', inline='5', tooltip=maTypelTip, options=['FMA','HFMA','SMA','HMA','WMA','DEMA','VWMA','VWAP','T3'])

maLength1 = input.int(len1, 'MA Length #1', group='ðŸ“ˆ MA Strateov Settings ðŸ“ˆ', inline='1', tooltip=maLength1Tip, minval=1)
maLength2 = input.int(len2, 'MA Length #2', group='ðŸ“ˆ MA Strateov Settings ðŸ“ˆ', inline='2', tooltip=maLength2Tip, minval=1)
maLength3 = input.int(len3, 'MA Length #3', group='ðŸ“ˆ MA Strateov Settings ðŸ“ˆ', inline='3', tooltip=maLength1Tip, minval=1)
maLength4 = input.int(len4, 'MA Length #4', group='ðŸ“ˆ MA Strateov Settings ðŸ“ˆ', inline='4', tooltip=maLength1Tip, minval=1)
maLength5 = input.int(len5, 'MA Length #5', group='ðŸ“ˆ MA Strateov Settings ðŸ“ˆ', inline='5', tooltip=maLength1Tip, minval=1)
hmabar = input.int(100, 'HMA Length', group='ðŸ“ˆ MA Strateov Settings ðŸ“ˆ', inline='6', tooltip=maLength1Tip, minval=1) 

maBull1 = input. color(#7962ff, 'Bull Color', inline='color1', group='ðŸ“ˆ MA Strateov Settings ðŸ“ˆ')
maBear2 = input.color(#c2185b, 'Bear Color', inline='color1', group='ðŸ“ˆ MA Strateov Settings ðŸ“ˆ')
transp1 = 0
transp2 = 0 
lineW1 = 1 
lineW2 = 1 
ema_fast = maType1
ema_slow = maType2

//-----------------------------------------------------------------------------}
//                               ðŸ”Ž Range Filters ðŸ”Ž
//-----------------------------------------------------------------------------{
// Sampling per_RFiod 
// Settings for 5min chart, BTCUSDC. For Other coin, change the paremeters 

RFactivate = input.bool( false, 'RF' , group="ðŸ”Ž Range Filter ðŸ”Ž", inline="RF1") 
per_RF = input.int(defval=100, minval=1, title='RF Period', group="ðŸ”Ž Range FilterðŸ”Ž ", inline="RF1") 

// Range Multiplier 
mult = input.float(defval=3.0, minval=0.1, title= 'RF Multi', group="ðŸ”Ž Range FilterðŸ”Ž ", inline="RF1") 

src_RF = close 


//-----------------------------------------------------------------------------}
//                           âš™ï¸ Functional Declarations  âš™ï¸
//-----------------------------------------------------------------------------{
smoothrng(x, t, m) => 
    wper_RF = t*2-1
    avrng = ta.ema(math.abs(x - x[1]), t) 
    smoothrng = ta.ema(avrng, wper_RF) * m
    smoothrng 
smrng = smoothrng (src_RF, per_RF, mult) 

// Range Filter 
rngfilt(x, r) => 
    rngfilt = x 
    rngfilt := x > nz(rngfilt[1]) ? x - r < nz(rngfilt [1]) ? nz(rngfilt[1]) : x - r : x + r > nz(rngfilt[1]) ? nz(rngfilt[1]) : x + r 
    rngfilt
filt = rngfilt(src_RF, smrng) 

// Filter Direction 
upward_RF = 0.0 
upward_RF := filt > filt[1] ? nz(upward_RF[1]) + 1 : filt < filt[1] ? 0 : nz(upward_RF[1])
downward_RF = 0.0 
downward_RF := filt < filt[1] ? nz (downward_RF[1]) + 1 : filt > filt[1] ? 0 :  nz(downward_RF[1])

// Target Bands
hband = filt + smrng 
lband = filt - smrng 

//-----------------------------------------------------------------------------}
//                                          VWAP
//-----------------------------------------------------------------------------{
f_vwap_func (vwapSRC, smaSRC, smaLen) => 
    valslow = ta.vwap (vwapSRC) 
    sma_close = ta.ema (smaSRC, smaLen) 
    is_vwap_below = valslow [1] > sma_close [1] 
    [valslow, sma_close, is_vwap_below]

//-----------------------------------------------------------------------------}
//                                          RSI
//-----------------------------------------------------------------------------{
f_rsi_func(rsiSource, rsiLength) => 
    rsiup = ta.rma (math.max(ta.change (rsiSource), 0), rsiLength) 
    rsidown = ta.rma(-math.min(ta.change (rsiSource), 0), rsiLength) 
    rsirsi = rsidown == 0 ? 100 : rsiup == 0 ? 0 : 100 - 100 / (1 + rsiup / rsidown) 
    rsivalue = rsirsi[1] 

//-----------------------------------------------------------------------------}
//                                          MFI
//-----------------------------------------------------------------------------{ 
f_mfi(mfiSource, mfiLength) => 
    mfiupper = math.sum(volume * (ta.change (mfiSource) <= 0 ? 0: mfiSource), mfiLength)
    mfilower = math.sum(volume * (ta.change (mfiSource) >= 0 ? 0: mfiSource), mfiLength)
    100.0 - 100.0 / (1.0 + mfiupper / mfilower) 

//-----------------------------------------------------------------------------}
//                                          ADX
//-----------------------------------------------------------------------------{
f_dirmov (len) =>
    up = ta.change (high) 
    down = -ta.change (low) 
    plusDM = na(up) ? na : up > down and up > 0 ? up : 0
    minusDM = na(down) ? na: down > up and down > 0 ? down : 0
    truerange = ta.rma(ta.tr, len) 
    plus = fixnan (100 * ta.rma(plusDM, len) / truerange) 
    minus = fixnan (100 * ta.rma (minusDM, len) / truerange) 
    [plus, minus] 
    
f_adx (dilen, adxlen) => 
    [plus, minus] = f_dirmov (dilen) 
    sum = plus + minus
    adx = 100 * ta.rma(math.abs(plus - minus) / (sum == 0 ? 1 : sum), adxlen)
    adx 


f_adx_func(ADXtype,_adxlen,_sadx_min_len,_sadx_max_len,_sadx_inv,_sadx_sm,_dilen,choppyLine) => 
    _sadx_up = ta.change (high)
    _sadx_down = -ta.change (low) 
    _sadx_plusDM = na (_sadx_up) ? na : _sadx_up > _sadx_down and _sadx_up > 0 ? _sadx_up : 1 
    _sadx_minusDM = na(_sadx_down) ? na : _sadx_down > _sadx_up and _sadx_down > 0 ? _sadx_down : 0 
    _sadx_truerange = ta.rma (ta.tr, _adxlen)
    _sadx_plus = fixnan(100 * ta.rma(_sadx_plusDM, _adxlen) / _sadx_truerange) 
    _sadx_minus = fixnan (100 * ta.rma(_sadx_minusDM, _adxlen) / _sadx_truerange) 
    _sadx_sum =  _sadx_plus + _sadx_minus 
    _sadx_adx = 100 * math.abs(_sadx_plus - _sadx_minus) / (_sadx_sum == 0 ? 1 : _sadx_sum)
    _sadx_rsi_adx = ta.rsi(_sadx_adx, _adxlen) 
    
    _sadx_st_min = ta.stoch(close, high, low, _sadx_min_len) 
    _sadx_st_max = ta.stoch(close, high, low, _sadx_max_len) 
    _sadx_st = _sadx_inv ? ta.sma((1 - _sadx_rsi_adx / 100) * _sadx_st_max + _sadx_rsi_adx / 100 * _sadx_st_min, _sadx_sm) : ta.sma(_sadx_rsi_adx / 100 * _sadx_st_max + (1 - _sadx_rsi_adx / 100) * _sadx_st_min, _sadx_sm) 

    _adx_masa_len = _adxlen 

    _adx_masa_TrueRange = math.max(math.max(high - low, math.abs(high - nz(close [1]))), math.abs(low - nz (close [1])))
    _adx_masa_DirectionalMovementPlus = high - nz(high [1]) > nz(low[1]) - low ? math.max(high - nz (high[1]), 0) : 0
    _adx_masa_DirectionalMovementMinus  = nz(low[1]) - low > high - nz(high[1]) ? math.max(nz(low [1]) - low, 0) : 0

    Smoothed_adx_masa_TrueRange = 0.0 
    Smoothed_adx_masa_TrueRange := nz(Smoothed_adx_masa_TrueRange[1]) - nz(Smoothed_adx_masa_TrueRange[1]) / _adx_masa_len + _adx_masa_TrueRange 
    Smoothed_adx_masa_DirectionalMovementPlus = 0.0 
    Smoothed_adx_masa_DirectionalMovementPlus := nz (Smoothed_adx_masa_DirectionalMovementPlus [1]) - nz(Smoothed_adx_masa_DirectionalMovementPlus[1]) / _adx_masa_len + _adx_masa_DirectionalMovementPlus
    Smoothed_adx_masa_DirectionalMovementMinus = 0.0 
    Smoothed_adx_masa_DirectionalMovementMinus := nz(Smoothed_adx_masa_DirectionalMovementMinus[1])-nz(Smoothed_adx_masa_DirectionalMovementMinus[1]) / _adx_masa_len + _adx_masa_DirectionalMovementMinus


    _adx_masa_DIPlus = Smoothed_adx_masa_DirectionalMovementPlus / Smoothed_adx_masa_TrueRange * 100
    _adx_masa_DIMinus = Smoothed_adx_masa_DirectionalMovementMinus / Smoothed_adx_masa_TrueRange * 100 
    _adx_masa_DX = math. abs (_adx_masa_DIPlus - _adx_masa_DIMinus) / (_adx_masa_DIPlus + _adx_masa_DIMinus) * 100 
    _adx_masa_ADX = ta.sma(_adx_masa_DX, _adx_masa_len)
    _sig = ADXtype == "Stoch" ? _sadx_st : ADXtype == "MasaNakamura" ? _adx_masa_ADX : f_adx(_dilen, _adxlen) 

    [_adx_masa_DIPlus,_adx_masa_DIMinus,_sig] 

//-----------------------------------------------------------------------------}
//                               Volumen Flow
//-----------------------------------------------------------------------------{
volume_flow_func(length, coef ,vcoef) => 
    typical = hlc3 
    inter = math.log (typical) - math.log(typical[1])
    vinter = ta.stdev (inter, 30) 
    cutoff = coef * vinter * close 
    vave = ta.sma(volume, length)[1] 
    vmax = vave * vcoef 
    vc = volume < vmax ? volume : vmax //min( volume, max 
    mf = typical - typical[1] 
    iff_1 = mf < -cutoff ? -vc : 0
    vcp = mf > cutoff ? vc : iff_1 
    
    vfi = math.sum(vcp, length) / vave

//-----------------------------------------------------------------------------}
//                               Heiken Ashi
//-----------------------------------------------------------------------------{
//heiken ashi //heiken ashi 
hq_func() =>  
    float _haopen = 0 
    _haclose = (open + high + low + close) / 4 
    _haopen := na(_haopen[1]) ? (open + close) / 2 : (_haopen[1] + _haclose [1]) / 2
    green_ha = _haclose > _haopen
    red_ha = _haclose < _haopen 
    greenToRed_ha = green_ha[1] and red_ha 
    redToGreen_ha = red_ha[1] and green_ha

    float top_haSwing = 0 
    float bottom_haSwing = 0 
    //lookback to find the highest high and lowest low poin_haTS in the _haSwings after the heiken ashi bar c_hanges color 
    top_haSwing := greenToRed_ha ? math.max(high[2], high[1], high ) : top_haSwing[1] 
    bottom_haSwing := redToGreen_ha ? math.min( low[2], low[1], low) : bottom_haSwing[1] 
    
    //trailing stop 
    float _haTS = 0 
    _haTS := close < _haTS[1] ? top_haSwing[1] : close > _haTS[1] ? bottom_haSwing[1] : _haTS 
    
//-----------------------------------------------------------------------------}
//                               Choppy
//-----------------------------------------------------------------------------{
_choppy_func() =>  
    col_green = 1
    col_green_slow = 1
    col_green_slower = 1
    col_red =  0
    col_red_slow = 0
    col_red_slower = 0
    col_chop = 0 
    
    histo = 10 
    
    choppyColor = if close[1] > close[2] and close[2] > close[3] and close[3] > close[4] and close[4] > close[5] and close[5] > close[6] 
        col_green 
    else if close[1] > close[2] and close[2] > close[3] and close[3] > close[4]
        col_green_slow 
    else if close[2] > close[3] and close[3] > close[4] and close[4] > close[5] and close[5] > close[6] 
        col_green_slower 
    else if close[1] > close[2] and close[3] > close[4] and close[4] > close[5] and close[5] > close[6] 
        col_green_slower
    else if close[1] > close[2] and close[2] > close[3] and close[4] > close[5] and close[5] > close[6] 
        col_green_slower
    else if close[1] > close[2] and close[2] > close[3] and close[3] > close[4] and close[5] > close[6] 
        col_green_slower
    else if close[1] > close[2] and close[2] > close[3] and close[3] > close[4] and close[4] > close[5]  
        col_green_slower
    else if close[1] < close[2] and close[2] < close[3] and close[3] < close[4] and close[4] < close[5] and close[5] < close[6] 
        col_green 
    else if close[1] < close[2] and close[2] < close[3] and close[3] < close[4]
        col_green_slow 
    else if close[2] < close[3] and close[3] < close[4] and close[4] < close[5] and close[5] < close[6] 
        col_green_slower 
    else if close[1] < close[2] and close[3] < close[4] and close[4] < close[5] and close[5] < close[6] 
        col_green_slower
    else if close[1] < close[2] and close[2] < close[3] and close[4] < close[5] and close[5] < close[6] 
        col_green_slower
    else if close[1] < close[2] and close[2] < close[3] and close[3] < close[4] and close[5] < close[6] 
        col_green_slower
    else if close[1] < close[2] and close[2] < close[3] and close[3] < close[4] and close[4] < close[5]  
        col_green_slower
    else
        col_chop 
    histo := choppyColor == col_green or choppyColor == col_green_slow or choppyColor == col_green_slower ? 10 : 0 
    main = histo [1] + histo [2] + histo [3] + histo [4] + histo [5] + histo [6] + histo [7] + histo [8] + histo [9] + histo [10] / 10 


//-----------------------------------------------------------------------------}
//                                  Volumen 
//-----------------------------------------------------------------------------{
f_vol_func (lookback) => 
    mma = ta.ema(close * 1000, lookback) 
    smma = ta.ema (mma, lookback) 
    
    impetmma = mma - mma [1] 
    impetsmma = smma - smma [1] 
    divma = math. abs (mma - smma) 
    averimpet = (impetmma + impetsmma) / 2
    
    number = averimpet 
    pow = 3
    result = 0.0

    for i = 1 to pow - 1 by 1
        if i == 1
            result := number
            result
        result += number
        result
    
    tdf = divma * result 
    ntdf = tdf / ta.highest(math.abs(tdf), lookback * 3 )
    
tema (src, len) =>
    tdfi_ema1 = ta.ema (src, len) 
    tdf1_ema2 = ta.ema(tdfi_ema1, len) 
    tdf1_ema3 = ta.ema (tdf1_ema2, len)  
    3 * tdfi_ema1 - 3 * tdf1_ema2 + tdf1_ema3 

ma(mode, src, len) => 
    mode == "ema" ? ta.ema(src, len) : mode == 'wma' ? ta.wma(src, len) : mode == 'swma' ? ta.swma(src) : mode == 'vwma' ? ta.vwma(src, len) : mode == 'hull' ? ta.wma(2 * ta.wma(src, len / 2) - ta.wma(src, len), math.round(math.sqrt(len))) : src


tdfi(_tdfiv2_mmaMode, _tdfiv2_price, _tdfiv2_mmaLength, s_tdfiv2_mmaLength, s_tdfiv2_mmaMode, _tdfiv2_nLength, _tdfiv2_lookback)=> 
    tdfi_mma = ma(_tdfiv2_mmaMode, _tdfiv2_price * 1000, _tdfiv2_mmaLength) 
    tdfi_smma = ma(s_tdfiv2_mmaMode, tdfi_mma, s_tdfiv2_mmaLength) 
    tdfi_impetmma = tdfi_mma - tdfi_mma [1] 
    tdfi_impetsmma = tdfi_smma - tdfi_smma [1] 
    tdfi_divma = math.abs(tdfi_mma - tdfi_smma) 
    tdfi_averimpet = (tdfi_impetmma + tdfi_impetsmma) / 2 
    tdfi_tdf = math.pow(tdfi_divma, 1) * math.pow(tdfi_averimpet, _tdfiv2_nLength)
    tdfi_tdf / ta.highest(math.abs(tdfi_tdf), _tdfiv2_lookback * _tdfiv2_nLength)
    

//-----------------------------------------------------------------------------}
//                              Simple functions 
//-----------------------------------------------------------------------------{
f_security(_symbol, _res, _src, _repaint)=>
     request.security(_symbol, _res, _src[_repaint ? 0 : barstate.isrealtime ? 1 : 0])[_repaint ? 0 : barstate.isrealtime ? 0 : 1] 
     //f_securitymacd(_symbol, repaint => security svmbol. 
     
_cross (a, b) => 
    ta.cross(a, b) [_repaint ? 0 : barstate.isrealtime ? 1 : 0] 
    
_crossover (a, b) => 
    ta.crossover(a, b) [_repaint ? 0 : barstate.isrealtime ? 1 : 0] 
    
_crossunder(a, b) => 
    ta.crossunder(a, b) [_repaint ? 0 : barstate.isrealtime ? 1 : 0] 

f_inRange (cond, rangelow, rangehi) =>
    bars = ta.barssince(cond == true) 
    rangelow <= bars and bars <= rangehi 
    // Function to calculate HA value for Bi HEMA MA type // 
    
_haOpen ( ) => 
    haClose = (open + high + low + close) / 4 
    haOpen = float (na) 
    haOpen := na(haOpen[1]) ? (open + close) / 2 : (nz(haOpen[1]) + nz(haClose[1])) / 2 
    haOpen 
    
HaOpen = _haOpen () 

// Custom MA function. This alows variable MA selection from the input menu. Funtion to be rendered later //

getROC ( source, length) => 
    roc = 100 * (source - source[length]) /source[length] 
    roc
    
getMAflat(input , type, length) => 
    maPrice = ta.ema(input, length) 
    if type == 'MA' 
        maPrice := ta.sma(input, length) 
        maPrice 
    if type == 'HEMA' 
        maPrice := ta.ema (HaOpen, length) 
        maPrice 
    if type == 'SMA'
        maPrice := ta.sma(input, length) 
        maPrice 
    if type == 'HMA' 
        maPrice := ta.hma(input, length) 
        maPrice 
    if type == 'WMA' 
        maPrice := ta.wma(input, length) 
        maPrice 
    if type == 'VWMA' 
        maPrice := ta.vwma(input, length) 
        maPrice 
    if type == 'VWAP' 
        maPrice := ta.vwap 
        maPrice 
    if type == 'DEMA' 
        e1 = ta.ema(input, length) 
        e2 = ta.ema(e1, length) 
        maPrice := 2 * e1 - e2 
        maPrice 
    if type == 'T3' 
        axel = ta.ema (input, length) 
        axe2 = ta.ema (axel, length) 
        axe3 = ta.ema (axe2, length) 
        axe4 = ta.ema (axe3, length)
        axe5 = ta.ema (axe4, length)
        axe6 = ta.ema (axe5, length)
        ab = 0.7
        ac1 = -ab * ab * ab
        ac2 = 3 * ab * ab + 3 * ab * ab * ab
        ac3 = -6 * ab * ab - 3 * ab - 3 * ab * ab * ab
        ac4 = 1 + 3 * ab + ab * ab * ab + 3 * ab * ab
        maPrice := ac1 * axe6 + ac2 * axe5 + ac3 * axe4 + ac4 * axe3
        maPrice
    maPrice

getMA(type, length) => 
    maPrice = getMAflat(close, type, length) 
    maPrice 
    
//-----------------------------------------------------------------------------}
//                                 Edit here  
//-----------------------------------------------------------------------------{
//This is where I add code to create the main strategy 
//Full Algo 

l= 0.0 

zigzag_len = input.int(13, "ZigZag Length") 

var float [] high_points_arr = array.new_float(5)
var int[] high_index_arr = array.new_int (5) 
var float[] low_points_arr = array.new_float (5) 
var int[] low_index_arr = array. new_int (5) 

to_up = high >= ta.highest (zigzag_len) 
to_down = low <= ta.lowest (zigzag_len) 

trend = 1 
trend := nz(trend [1], 1) 
trend := trend == 1 and to_down ? -1 : trend == -1 and to_up ? 1 : trend

last_trend_up_since = ta.barssince(to_up[1]) 
low_val = ta.lowest(nz(last_trend_up_since > 0 ? last_trend_up_since : 1, 1))
low_index = bar_index - ta.barssince(low_val == low) 

last_trend_down_since = ta.barssince(to_down[1]) 
high_val = ta.highest(nz(last_trend_down_since > 0 ? last_trend_down_since: 1, 1))
high_index = bar_index - ta.barssince(high_val == high) 

if ta.change(trend) != 0
    if trend == 1 
        array.push (low_points_arr, low_val) 
        array.push (low_index_arr, low_index) 
    if trend == -1 
        array.push (high_points_arr, high_val) 
        array.push (high_index_arr, high_index)
 
f_get_high(ind) => 
    [array.get(high_points_arr, array.size(high_points_arr) - 1 - ind), array.get(high_index_arr, array.size(high_index_arr) - 1 - ind)] 
    
f_get_low (ind) => 
    [array.get(low_points_arr, array.size(low_points_arr) - 1 - ind), array.get(low_index_arr, array.size(low_index_arr) - 1 - ind)] 
    
[h0, h0i] = f_get_high(0) 
[l0, l0i] = f_get_low(0) 
[h1, h1i] = f_get_high(1) 
[l1, l1i] = f_get_low (1)
[h2, h2i] = f_get_high(2) 
[l2, l2i] = f_get_low (2) 

bu_cond = trend == -1 and h2 > h1 and l1 > l0 and h0 > h1 and close > l1 
be_cond = trend == 1 and l2 < l1 and h1 < h0 and l0 < l1 and close < h1 

if bu_cond and not bu_cond[1] 
    line.new(h2i, h2, l1i, l1, color=color.green, width=2) 
    line.new(l1i, l1, h1i, h1, color=color.green, width=2) 
    line.new(h1i, h1, l0i, l0, color=color.green, width=2) 
    line.new(l0i, l0, h0i, h0, color=color.green, width=2) 
    line.new(l1i, l1, bar_index, l1, color=color.green, width=2) 
    label.new(bar_index, l1, "", style=label.style_label_up, textcolor=color.white, color=color.green, size=size.tiny) 
    alert ("Bullish OM!", alert.freq_once_per_bar) 

if be_cond and not be_cond [1] 
    line.new(l2i, l2, h1i, h1, color=color.red, width=2) 
    line.new(h1i, h1, l1i, l1, color=color.red, width=2) 
    line.new(l1i, l1, h0i, h0, color=color.red, width=2) 
    line.new(h0i, h0, l0i, l0, color=color.red, width=2)
    line.new(h1i, h1, bar_index, h1, color=color.red, width=2) 
    label.new(bar_index, h1, "", style=label.style_label_down, textcolor=color.white, color=color.red, size=size.tiny) 
    alert ("Bearish OM!", alert.freq_once_per_bar) 
    

enter_long = bu_cond and not bu_cond[1] 
enter_short = be_cond and not be_cond[1] 

force_exit_signal_short = enter_long 
force_exit_signal_long = enter_short 

//Custom SL 
custom_longStop = 1.0 
custom_shortStop = 1.0 

custom_longTP = 1.0 
custom_shortTP = 1.0 

//Dashboard lights 
_take_long_one = enter_long 
_take_long_two = enter_long 
_take_long_three = enter_long 

_take_short_one = enter_short 
_take_short_two = enter_short
_take_short_three = enter_short 

textStepOne_long = 'Step 1 LONG' //Text for redLight LONG 
textStepTwo_long = 'Step 2 LONG' //Text for purplelight LONG 
textStepThree_long = 'Step 3 LONG' //Text for amberlight LONG 
textStepFour_long = 'LONG Position made' //Text for greenlight LONG 

textStepOne_short ='Step 1 SHORT' //Text for redLight SHORT 
textsteptwo_short = 'Step 2 SHORT' //Text for purplelight SHORT 
textStepThree_short = 'Step 3 SHORT' //Text for amberlight SHORT 
textStepFour_short = 'SHORT Position made' //Text for greenlight SHORT 

force_exit = input(title='Force Exit On Exit Signal ?', defval=false) 
force_exit_long = force_exit ? force_exit_signal_long: false 
force_exit_short = force_exit ? force_exit_signal_short: false 

//-----------------------------------------------------------------------------}
//                           EMA and HMA Functions  
//-----------------------------------------------------------------------------{

len6 = hmabar 
src6 = close 
hma = ta.wma(2 * ta.wma(src6, len6 / 2) - ta.wma(src6, len6), math. floor (math.sqrt (len6) )) 
hmacolor = close > hma ? maBull1: maBear2 
plot(boolhmabar ? hma : na, title='HMA Line', color=color.new(hmacolor, 65), linewidth=5)

// EMA 5 EMAs //
price = plot(_useMA != 'Off' ? close : na, title="Close Line", color=color.blue, display=display.none) 
out1 = getMA (maType1, maLength1) 
ema1color = (out1 > out1[1] ? maBull1: maBear2) 
ema1 = plot (boolmaLength1 ? out1 :na, title="EMA 9", linewidth=3, color=color.new(ema1color, 50), offset=0, display=display.none) 
fill(price, ema1, title="EMA 9 FILL", color=color.new(ema1color, 95), editable=true) 
src2 = close 
out2 = getMA (maType2, maLength2) 
ema2color = (out2 > out2[1] ? maBull1: maBear2) 
ema2 = plot (boolmaLength2 ? out2 :na, title="EMA 21", linewidth=3, color=color.new(ema2color, 50), offset=0, display=display.none) 
fill(price, ema2, title="EMA 21 FILL", color=color.new(ema2color, 95), editable=true) 
src3 = close 
out3 = getMA (maType3, maLength3) 
ema3color = (out3 > out3[1] ? maBull1: maBear2) 
ema3 = plot (boolmaLength3 ? out3 :na, title="EMA 55", linewidth=3, color=color.new(ema3color, 50), offset=0, display=display.none) 
fill(price, ema3, title="EMA 55 FILL", color=color.new(ema3color, 95), editable=true) 
src4 = close 
out4 = getMA (maType4, maLength4) 
ema4color = (out4 > out4[1] ? maBull1: maBear2) 
ema4 = plot (boolmaLength4 ? out4 :na, title="EMA 100", linewidth=3, color=color.new(ema4color, 50), offset=0, display=display.none) 
fill(price, ema4, title="EMA 100 FILL", color=color.new(ema4color, 95), editable=true) 
src5 = close 
out5 = getMA (maType5, maLength5) 
ema5color = (out5 > out5[1] ? maBull1: maBear2) 
ema5 = plot (boolmaLength5 ? out5 :na, title="EMA 200", linewidth=3, color=color.new(ema5color, 50), offset=0, display=display.none) 
fill(price, ema5, title="EMA 200 FILL", color=color.new(ema5color, 95), editable=true) 

ma1CrossUp2 = _crossover(out1, out5) 
ma1CrossDn2 = _crossunder (out1, out5) 
ma1Con = out1 >= out1 [1] // create a rising condition for MA 
ma2Con = out5 >= out5 [1] 
ma1Col = ma1Con ? maBull1 : maBull1 // check if MA is rising, assing a color 
ma2Col = ma2Con ? maBear2 : maBear2

emcolor = close < out5 ? color.red : color.green
plot(_useMA != 'Off' ? out5 : na, title="EMA", color=emcolor) 

longema_ordered = close > out5 and out1 > out2 and out2 > out3 and out4 > out5
shortema_ordered = close < out5 and out1 < out2 and out2 < out3 and out4 < out5

valout1 = boolmaLength1 ? out1 : out1
valout2 = boolmaLength2 ? out2 : out1
valout3 = boolmaLength3 ? out3 : out1
valout4 = boolmaLength4 ? out4 : out1
valout5 = boolmaLength5 ? out5 : out5
long_ema_checked = out1 > out2 and out2 > out5 and out1 > out5
short_ema_checked = out1 < out2 and out2 < out5 and out1 < out5

long_ema_checked_strict = out1 > out5
short_ema_checked_strict = out1 < out5

long_ema_checked_cross = out1 > out2 and out1[1] < out2[1] and out2 > out5 and out1 > out5
short_ema_checked_cross = out1 < out2 and out1[1] > out2[1] and out2 < out5 and out1 < out5


ema_theema_long = _useMA == 'Close over/under MA5' ? close > out5 : _useMA == 'Strict Close over/under MAS' ? close > out5 and close[1] > out5[1] : _useMA == 'Ordered MA1,MA2,MA3,MA4,MA5' ? longema_ordered : _useMA == 'Tripple MA MA1,MA2,MA5' ? long_ema_checked: _useMA == 'Tripple MA MA1,MA2,MA5 (Strict)' ? long_ema_checked_strict: _useMA == 'Tripple MA MA1, MA2, MA5 (Cross)' ? long_ema_checked_cross : true

ema_theema_short = _useMA == 'Close over/under MA5' ? close < out5 : _useMA == 'Strict Close over/under MAS' ? close > out5 and close[1] > out5[1] : _useMA == 'Ordered MA1,MA2,MA3,MA4,MA5' ? shortema_ordered :  _useMA == 'Tripple MA MA1,MA2,MA5' ? short_ema_checked: _useMA == 'Tripple MA MA1,MA2,MA5 (Strict)' ? short_ema_checked_strict: _useMA == 'Tripple MA MA1, MA2, MA5 (Cross)' ? short_ema_checked_cross : true


ema_theema_long_1 = tredreversal ? ema_theema_short : ema_theema_long
ema_theema_short_1 = tredreversal ? ema_theema_long :  ema_theema_short 

ema_theema_long := ema_theema_long_1 
ema_theema_short := ema_theema_short_1 

//DON'T FORGET REVERAL 

ema_theema_long_hma = boolhmabar ? close > hma : true
ema_theema_short_hma = boolhmabar ? close < hma : true 

ema_theema_long := ema_theema_long and ema_theema_long_hma 
ema_theema_short:= ema_theema_short and ema_theema_short_hma 

stepOneShort = ema_theema_short and _take_short_one 
stepTwoShort = ema_theema_short and _take_short_two// e.g stepTwoShort = crossover (a,b) and a-b 
stepThreeShort = ema_theema_short and _take_short_three 

stepOneLong = ema_theema_long and _take_long_one 
stepTwoLong = ema_theema_long and _take_long_two 
stepThreeLong = ema_theema_long and _take_long_three





//â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
// >>>>>>>>>>>>>>>>>>>> USER INPUTS PART 2 - EXTRA FILTERS  <<<<<<<<<<<<<<<<<<<<<<<<
//â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
//-----------------------------------------------------------------------------}
//                           ðŸ«¨ Max Trades In One Direcions ðŸ«¨  
//-----------------------------------------------------------------------------{
enablemaxtradespercross = input.bool(_maxtrades_on, title='Enable Max Trades?' , group= 'ðŸ«¨ Max Trades In One DirecionsðŸ«¨ ') 
maxtradespercross = input.int(5, title= 'Max Trades Per Direction?', group= 'ðŸ«¨ Max Trades In One DirecionsðŸ«¨ ') 

//-----------------------------------------------------------------------------}
//                           ðŸ”Ž ADX Settings - Extra Filters ðŸ”  
//-----------------------------------------------------------------------------{
enableadx = input.bool(_adx_on, title='Enable ADX ?', group= 'ðŸ”Ž ADX Settings - Extra Filters ðŸ”') 

ADXtype = input.string( 'Normal', 'ADX Type', group= 'ðŸ”Ž ADX Settings - Extra Filters ðŸ”', options=['Normal', 'Stoch', 'MasaNakamura ']) 
ADXSM = input.string('Static', 'ADX Line Type', group= 'ðŸ”Ž ADX Settings - Extra Filters ðŸ”', options=['Static', 'MA', 'EMA', 'SMA', 'HMA', 'WHA', 'DEMA', 'VWMA', 'T3']) 

_adxlen = input.int(14, title='ADX Smoothing', group='ðŸ”Ž ADX Settings - Extra Filters ðŸ”') 
_dilen = input.int(14, title='DI Length', group= 'ðŸ”Ž ADX Settings - Extra Filters ðŸ”' ) 
adxline = input.int(30, minval=0, title='ADX Above line', group= 'ðŸ”Ž ADX Settings - Extra Filters ðŸ”' ) 
adxlinelen = input.int(200, minval=0, title='ADX MA Length', group= 'ðŸ”Ž ADX Settings - Extra Filters ðŸ”' ) 

enableDI = input.bool(false, title='Use DI for Direction ?', group='ðŸ”Ž ADX Settings - Extra Filters ðŸ”') 

_sadx_min_len = input(19, title='Min stoch Length', group='ðŸ”Ž ADX Settings - Extra Filters ðŸ”') 
_sadx_max_len = input(100, title='Max stoch length Smoothing', group='ðŸ”Ž ADX Settings - Extra Filters ðŸ”') 
_sadx_sm = input(2, title='Stoch Smoothing', group='ðŸ”Ž ADX Settings - Extra Filters ðŸ”') 
_sadx_inv = input(false, title= 'Inverse adaptive', group='ðŸ”Ž ADX Settings - Extra Filters ðŸ”') 
enableadx_roc = input.bool(false, title='Use Rate of Change?', group='ðŸ”Ž ADX Settings - Extra Filters ðŸ”') 

enableha = input.bool(_adx_on, title= 'Enable HA Overlay ?', group= 'HA Overlay Settings - Extra Filters') 

//-----------------------------------------------------------------------------}
//                           ðŸ”Ž TDFI Settings - Extra Filter ðŸ”  
//-----------------------------------------------------------------------------{
volconfirm = input.bool(false, 'Volume confirm?', inline="v1", group='ðŸ”Ž TDFI Settings - Extra Filter ðŸ”' )
_tdfi_version = input.string(title='Version to use?', defval='v1', options=['v1','v2'], group='ðŸ”Ž TDFI Settings - Extra Filter ðŸ”' )
lookback = input(20, title='TDFI Lookback', inline="v1", group='ðŸ”Ž TDFI Settings - Extra Filter ðŸ”') 
filterHigh = input.float(0.05, title='Filter High', inline="v2", group='ðŸ”Ž TDFI Settings - Extra Filter ðŸ”') 
filterLow = input.float(-0.05, title='Filter low', inline="v2", group='ðŸ”Ž TDFI Settings - Extra Filter ðŸ”', step=0.01)
_tdfiv2_lookback = lookback
_tdfiv2_mmaLength = input (13, title='MMA Length v2', group='ðŸ”Ž TDFI Settings - Extra Filter ðŸ”') 
_tdfiv2_mmaMode = input.string(title= 'MMA Mode v2', defval='ema', options=['ema', ' wma', 'swima', 'vwma', 'hull', 'tema'], group='ðŸ”Ž TDFI Settings - Extra Filter ðŸ”') 
s_tdfiv2_mmaLength = 13
s_tdfiv2_mmaMode = input.string(title= 'SMMA Mode v2', defval='ema', options=['ema', 'wma', 'swma', 'vwma', 'hull', 'tema'], group='ðŸ”Ž TDFI Settings - Extra Filter ðŸ”') 
_tdfiv2_nLength = input(3, title='N Length v2', group='ðŸ”Ž TDFI Settings - Extra Filter ðŸ”') 

//-----------------------------------------------------------------------------}
//                        ðŸ”Ž RSI Settings - Extra Filter ðŸ”  
//-----------------------------------------------------------------------------{
enablersi = input.bool(_rsi_on, title='Enable RSI ?', group='RSI Settings - Extra Filters') 
rsiSource = input.source(title= 'RSI Source' , defval=close, group='RSI Settings - Extra Filters') 
rsiLength = input.int(title='RSI Length', defval=14, group='RSI Settings - Extra Filters') 
rsiOverbrought = input.int(title='RSI Overbrought', defval=51, group='RSI Settings - Extra Filters') 
rsiOversold = input.int(title='RSI Oversold', defval=49, group= 'RSI Settings - Extra Filters')

//-----------------------------------------------------------------------------}
//                       ðŸ”Ž Volumen Settings - Extra Filter ðŸ”  
//-----------------------------------------------------------------------------{
_vf_enable = input.bool( false, title='Enable Volume Flow ?', group='ðŸ”Ž Volume Flow - Extra Filters ðŸ”') 
_vf_length = input (130, title='VFI length', group='ðŸ”Ž Volume Flow - Extra Filters ðŸ”') 
_vf_coef = input(0.2, title='Coef', group='ðŸ”Ž Volume Flow - Extra Filters ðŸ”') 
_vf_vcoef = input(2.5, title='Max. vol. cutoff', group='ðŸ”Ž Volume Flow - Extra Filters ðŸ”') 

enablemfi = input.bool(_mfi_on, title='Enable MFI ?', group='ðŸ”Ž MFI Settings - Extra Filters ðŸ”') 
mfiSource = input.source(title= 'MFI Source', defval=hlc3, group= 'ðŸ”Ž MFI Settings - Extra Filters ðŸ”') 
mfiLength = input.int(title= 'MFI Length', defval=14, group= 'ðŸ”Ž MFI Settings - Extra Filters ðŸ”') 
mfiOverbrought = input.int(title='MFI Overbrought', defval=51, group='ðŸ”Ž MFI Settings - Extra Filters ðŸ”') 
mfiOversold = input.int(title='MFI Oversold', defval=49, group= 'ðŸ”Ž MFI Settings - Extra Filters ðŸ”') 

//-----------------------------------------------------------------------------}
//                     ðŸ“ Flat Market - Extra Filters ðŸ“  
//-----------------------------------------------------------------------------{
enablechoppy = input.bool(_flat_on, title='Enable Flat Market ?', group= 'ðŸ“ Flat Market - Extra Filters ðŸ“')
flatmaType = input.string('Static', options=['Static', 'EMA', 'SMA', 'HMA', 'WMA', 'DEMA', 'VWMA', 'T3'], group='ðŸ“ Flat Market - Extra Filters ðŸ“')
flatmaLength = input.int(100, 'MA Length Flat Market', group = 'ðŸ“ Flat Market - Extra Filters ðŸ“', inline='f1',  minval=1) 
choppyline = input.float(30.0, minval=0, maxval=100, title= 'Flat Market Above Line', group='ðŸ“ Flat Market - Extra Filters ðŸ“', inline='f1') 
enablefm_roc = input.bool(false, title='Use Rate of Change?', group= 'ðŸ“ Flat Market - Extra Filters ðŸ“', tooltip='The Rate of Change indicator (ROC) is a momentum oscillator. It calculates the percent change in price between peri ') 


//-----------------------------------------------------------------------------}
//                                ðŸ“ VWAP ðŸ“  
//-----------------------------------------------------------------------------{
vwapBreakout = input.bool(_vwap_on, title='Use VWAP / EMA', group= 'ðŸ“ WWAP crossover - Extra Filters ðŸ“') 
vwapSRC = input.source (close, title= 'VWAP Source', group= 'ðŸ“ WWAP crossover - Extra Filters ðŸ“') 
smaSRC = input.source (close, title='VWAP Source', group= 'ðŸ“ WWAP crossover - Extra Filters ðŸ“') 
smaLen = input.int(3, title='VWAP Length', group= 'ðŸ“ WWAP crossover - Extra Filters ðŸ“') 
[valslow, sma_close, is_vwap_below] = f_vwap_func(vwapSRC, smaSRC, smaLen) 

//-----------------------------------------------------------------------------}
//                             ðŸ•  TIME SESSIONS ðŸ• 
//-----------------------------------------------------------------------------{
useTimeFilter = input.bool( false, 'Use Time Session Filter', group='ðŸ• Time Filters ðŸ•', tooltip=useTimeFilterTip) 
timezones = input.string( 'GMT+2', 'Timezone', group='ðŸ• Time Filters ðŸ•', options=['GMT-12', 'GMT-11', 'GMT-10', 'GMT-9', 'GMT-8', 'GMT-7', 'GMT-6', 'GMT-5', 'GMT-4', 'GMT-3', 'GMT-2', 'GMT-1', 'GMT', 'GMT+12', 'GMT+11', 'GMT+10', 'GMT+9', 'GMT+8', 'GMT+7', 'GMT+6', 'GMT+5', 'GMT+4', 'GMT+3', 'GMT+2', 'GMT+1']) 
timeSession = input.session('9000-0300', 'Tine Session To Ionore Trades', group='ðŸ• Time Filters ðŸ•', tooltip=timeSessionTip) 
useDateFilter = input.bool( false, 'Use Date Session Filter', group= 'ðŸ• Time Filters ðŸ•', tooltip=useTimeFilterTip)

startTime = input.time(timestamp('01 Jan 2000 00:00'), 'Start Filter', group='ðŸ• Time Filters ðŸ•', tooltip=startTimeTip)
endTime = input.time(timestamp ('01 Jan 2099 00:00'), 'End Filter', group='ðŸ• Time Filters ðŸ•', tooltip=endTimeTip)

monday = input.bool(true, title= 'Mon', group='ðŸ—“ï¸ Week Days to enter trade? ðŸ—“ï¸', inline="weekdays") 
tuesday = input.bool(true, title='Tue', group='ðŸ—“ï¸ Week Days to enter trade? ðŸ—“ï¸', inline="weekdays")
wednesday = input.bool(true, title='Wed', group='ðŸ—“ï¸ Week Days to enter trade? ðŸ—“ï¸',inline="weekdays") 
thursday = input.bool(true, title= 'Thur', group='ðŸ—“ï¸ Week Days to enter trade? ðŸ—“ï¸', inline="weekdays") 
friday = input.bool(true, title='Fri', group='ðŸ—“ï¸ Week Days to enter trade? ðŸ—“ï¸',inline="weekdays") 
saturday = input.bool(true, title='Sat', group='ðŸ—“ï¸ Week Days to enter trade? ðŸ—“ï¸', inline="weekdays")
sunday = input.bool(true, title='Sun', group='ðŸ—“ï¸ Week Days to enter trade? ðŸ—“ï¸', inline="weekdays")


//â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
// >>>>>>>>>>>>>>>>>>>> DASHBOARD  <<<<<<<<<<<<<<<<<<<<<<<<
//â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
_dd_useDavidd = input (false, title="Use DaviddTech Bot? ", group='Daviddtech Bot') 
_dd_margin = input.string(title='Margin' , options=['Percent of Portfolio %', 'USDT Amount', 'Strategy Based'], group='Daviddtech Bot', defval='Percent of Portfolio %')
_dd_margin_value = input.float(0.0,title='Margin Value', tooltip='Percent or Dollar amount of your portfolio to use?', group='Daviddtech Bot') 

_dd_api_key = input("***",title='API Key', group= 'DaviddTech Bot', inline="api") 
_dd_api_secret = input("***", title= 'API Secret', group= 'DaviddTech Bot', inline="api") 

_dd_order_type_entry = input.string(title='Entry Type', defval='Market', options=['Market', 'Limit'], inline="marketlimit", group='Daviddtech Bot') 
_dd_order_type_exit = input.string(title='Exit Type', defval='Limit', options= ['Market', 'Limit'], inline="marketlimit", group='DaviddTech Bot') 
_dd_discord = input("123456" ,title='Discord ID', group='DaviddTech Bot', tooltip='This will help you for debugging.') 
_dd_email = input("test@test.com", title='Email Address', group= 'DaviddTech Bot', tooltip='Must be the email address used to login to davidd. tech')

useAlerts = input.bool(false, title='Use Strategy Alerts? - Please read the tooltip', group= 'The Alerts', tooltip='Using strategy alerts to count the 2' ) 
alertfreq = input.string(title='Alert Frequency', defval='Once per bar', options=['Once per bar', 'Once per close', 'All'], group= 'The Alerts' ) 

drawEntry = input.bool(_plot_on, 'Plot Entry/SL/TP', group='Display', tooltip=drawEntryTip) 
exitLvl = input.bool(true, 'Plot trail trigger price', group='Display', tooltip=exitLvlTip) 
dashOn = input.bool(true, 'Dashboard On / Off', group= 'DaviddTech Dashboard') 
logOn = input.bool(false, 'Log On / Off', group= 'DaviddTech Dashboard') 

dashDist = input.int(13, 'Dashboard Distance', group= 'DaviddTech Dashboard') 
dashColor = input.color(color.new(#696969, 80), 'Dashboard Color' , inline='Dash Line', group= 'DaviddTech Dashboard' ) 
dashTextColor = input.color(color.new(#ffffff, 0), 'Text Color', inline='Dash Line', group= 'DaviddTech Dashboard' ) 
notes = input.string('', title='Notes', group= 'DaviddTech Dashboard' ) 
watermark_show = input.bool(true, 'Show Watermark?' , group="Display") 



var bool _hasTable1 = input.bool(true, 'T', group='Table', inline= 'Table', tooltip='TABLE PROPERTIES\Label BG Color\nLabel Text Color\nValue BG Color\nValue Text Color\nTable Position\nText Size')

var color _table1LBG = input.color (color.rgb (209, 212, 220, 60), group='Table', inline='Table') 
var color _table1LTC = input.color(color.rgb (0,0, 0, 40), group='Table', inline='Table') 
var color _table1VBG = input.color (color.rgb (255, 224, 278, 60), group='Table', inline='Table') 
var color _table1VTC = input.color(color.rgb (255, 0, 0, 40), group='Table' , inline='Table') 
var string _table1PosInp = input.string('BL', options=['TL', 'TC', 'TR', 'ML', 'MC', 'MR', 'BL', 'BC', 'BR'], group= 'Table', inline='Table')  

var string _table1SizeInp = input.string('Auto', '', options=['Auto', 'Huge', 'Large', ' Normal', 'Small', 'Tiny'], group= 'Table', inline='Table')   

var color _tableFramel = input.color (color.rgb(100, 100, 100, 100), 'Table Frame', group='Table', inline= 'Frame', tooltip='Color\nTickness') 
var int _tableFrameT = input.int(0, '', minval=0, maxval=10, group= 'Table', inline='Frame') 
var color _tableBorderC = input.color(color.rgb(100, 100, 100, 100), 'Table Border', group='Table', inline='Border', tooltip='Color\nTickness') 
var int _tableBorderT = input.int(2, '', minval=0, maxval=10, group='Table', inline='Border')
var color _tableBGColor = color.rgb(100, 100, 100, 100)

var bool _hasDarkMode = input.bool(true, 'Dark Mode | Bull | Bear | Notr', group= 'Table' , inline='Color') 
var color _colorBull = input.color(color.rgb(3, 77, 64, 0), title='colorBull', inline='Color', group='Table' ) 
var color _colorbear = input.color (color.rgb(183, 77, 64, 0), title='colorbear', inline='Color', group='Table' ) 
var color _cOLOrOtr = input.color(color.rgb (14, 71, 161, 85), title='colorbear', group='Table', inline='Color') 


//â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
// >>>>>>>>>>>>>>>>>>>> LOGIC  <<<<<<<<<<<<<<<<<<<<<<<<
//â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
//-----------------------------------------------------------------------------}
//                          Range Filter
//-----------------------------------------------------------------------------{
filtcolor = upward_RF > 0 ? color.lime : downward_RF > 0 ? color.red: color.orange 
range_filter = upward_RF > 0 ? 1 : downward_RF > 0 ? -1 : 0
filtplot = plot (RFactivate ? filt : na, color=filtcolor, linewidth=3, title='Range Filter')

RFLong = RFactivate ? range_filter == 1 : true 
RFShort = RFactivate ? range_filter == -1 : true 

//-----------------------------------------------------------------------------}
//                          Volume Flow
//-----------------------------------------------------------------------------{

_vf_ = _vf_enable ? volume_flow_func(_vf_length, _vf_coef, _vf_vcoef) : 0
_vf_short = _vf_enable ? _vf_ < 0 : true
_vf_long = _vf_enable ? _vf_ > 0 : true

_tdfiv2_filterHigh = filterHigh 
_tdfiv2_filterLow = filterLow 
_tdfiv2_price = close 

ntdf = f_vol_func(lookback)
tdfi_signal = tdfi(_tdfiv2_mmaMode,_tdfiv2_price,_tdfiv2_mmaLength,s_tdfiv2_mmaLength,s_tdfiv2_mmaMode, _tdfiv2_nLength, _tdfiv2_lookback) 
tdfiv2_c = tdfi_signal > _tdfiv2_filterHigh ? 1 : tdfi_signal < _tdfiv2_filterLow ? -1 : 0
v_Long = ntdf > filterHigh ? 1 : 0 
v_Short = filterLow > ntdf ? 1 : 0 
volumeLong = volconfirm ? _tdfi_version == "v2" ? tdfiv2_c == 1 : v_Long : true 
volumeShort = volconfirm ? _tdfi_version == "v2" ? tdfiv2_c == -1 : v_Short : true

//-----------------------------------------------------------------------------}
//                          Time Sessions
//-----------------------------------------------------------------------------{
ff_color = color.new(color.red, 90) 

oktotradonthisday = (not monday and dayofweek == dayofweek.monday) or (not tuesday and dayofweek == dayofweek.tuesday) or (not wednesday and dayofweek == dayofweek.wednesday) or(not thursday and dayofweek == dayofweek.thursday) or (not friday and dayofweek == dayofweek.friday) or (not saturday and dayofweek == dayofweek.saturday) or (not sunday and dayofweek == dayofweek.sunday)

bgcolor(oktotradonthisday ? ff_color : na) 

daysOfWeek = '1234567'

isInSession(sess) => 
    na(time (timeframe.period, sess + ':' + daysOfWeek, timezones)) == false 

//-----------------------------------------------------------------------------}
//                          Alerts PANEL
//-----------------------------------------------------------------------------{

//input.text_area (defval = "Hello \nWorld!", title = "Message") 
threecommasenter = input.text_area('For Connections with 3rd Party services. In **Placeholders** \n\n Close : #close# \n TP #LongTP# \n TP1', title='API Enter - Long', group= 'The Alerts')
threecommasexit =input.text_area('3commas ,alerteron etc', title='API Exit - Long', group= 'The Alerts') 
threecommasenter_short = input.text_area('For Connections with 3rd Party services. \n **Placeholders** \n\n Close : #close# \n TP #ShortT#', title='API Enter - Short', group= 'The Alerts')
threecommasexit_short =input.text_area('3commas,alerteron etc', title='API Exit - Short', group= 'The Alerts') 
threecommasexitx1 = input.text_area ('3commas, alerteron etc', title='API First TP - Long', group= 'The Alerts - Multiple Take Profit Levels') 
threecommasexit_shortx1 = input.text_area ('3commas, alerteron etc', title='API First TP - Short', group= 'The Alerts - Multiple Take Profit Levels')
threecommasexitx2 = input.text_area(' Short', group= 'The Alerts - Multiple Take Profit Levels', title='API Second TP - Long')
threecommasexit_shortx2 = input.text_area ('3commas, alerteron etc', title='API Second TP - Short' , group= 'The Alerts - Multiple Take Profit Levels') 
threecommasenter := str.tostring(threecommasenter)
threecommasexit := str.tostring(threecommasexit)
threecommasenter_short := str.tostring(threecommasenter_short) 
threecommasexit_short := str.tostring(threecommasexit_short) 
threecommasexitx1 := str.tostring(threecommasexitx1) 
threecommasexit_shortx1 := str.tostring(threecommasexit_shortx1) 
threecommasexitx2 := str.tostring(threecommasexitx2)
threecommasexit_short := str.tostring(threecommasexit_shortx2) 


//-----------------------------------------------------------------------------}
//                          VWAP
//-----------------------------------------------------------------------------{
vwap_close_plot = plot(vwapBreakout ? valslow: na, title= 'VWAP close', color=is_vwap_below ? color.red : color.lime) 
sma_close_plot = plot(vwapBreakout ? sma_close : na, title= 'VWAP2 close',color=is_vwap_below ? color.red : color.lime) 
fill(vwap_close_plot, sma_close_plot, color=color.new(is_vwap_below ? color.red : color.lime, 85))
useVwapShort= vwapBreakout ? valslow[1] > sma_close[1] : true 
useVwapLong = vwapBreakout ? valslow[1] < sma_close[1] : true 

rsiValue = f_rsi_func(rsiSource, rsiLength) 
rsishorty = enablersi ? rsiValue > rsiOverbrought : true 
rsilongy = enablersi ? rsiValue < rsiOversold : true 

//-----------------------------------------------------------------------------}
//                          MFI 
//-----------------------------------------------------------------------------{
_mfi = f_mfi(mfiSource, mfiLength)[1] 
mfishorty = enablemfi ? _mfi > mfiOverbrought : true 
mfilongy = enablemfi ? _mfi < mfiOversold : true

//-----------------------------------------------------------------------------}
//                          ADX
//-----------------------------------------------------------------------------{
[_adx_masa_DIPlus,_adx_masa_DIMinus,_sig]=f_adx_func(ADXtype,_adxlen,_sadx_min_len,_sadx_max_len,_sadx_inv,_sadx_sm,_dilen,choppyline) 
sig_ema = ta.sma(_sig, adxlinelen) 
_adxline = ADXSM == "Static" ? adxline : getMAflat(_sig, ADXSM, adxlinelen) 
roc_adx = getROC(_adxline, 9 )

adxlongshort = enableadx ? enableadx_roc ? roc_adx >= 0 and _sig > _adxline : _sig > _adxline : true 
DIshorty = enableDI ? _adx_masa_DIPlus < _adx_masa_DIMinus : true
DIlongy = enableDI ? _adx_masa_DIPlus > _adx_masa_DIMinus : true 

//-----------------------------------------------------------------------------}
//                          Heiken Ashi
//-----------------------------------------------------------------------------{
_haTS = hq_func () 
plot (enableha ? _haTS <= 0 ? _haTS[1] : _haTS : na, title='Heiken Ashi Candles', color=close < _haTS ? color.red : color.green) 

longha = enableha ? close > _haTS : true 
shortha = enableha ? close < _haTS : true 

//-----------------------------------------------------------------------------}
//                          Choppy
//-----------------------------------------------------------------------------{
main = _choppy_func() 

choppyline := flatmaType == 'Static' ? choppyline : getMAflat(main, flatmaType, flatmaLength) 
line_new = choppyline / 10 

roc_fm = getROC (main, 9) 

cmlongy = enablechoppy ? enablefm_roc ? roc_fm > 0 and choppyline < main : choppyline < main : true 
cmshorty= enablechoppy ? enablefm_roc ? roc_fm < 0 and choppyline < main : choppyline < main : true 

//-----------------------------------------------------------------------------}
//                          MAX TRADE CROSS OVER
//-----------------------------------------------------------------------------{
var countall = 0 
numberoftrades = countall 

countall := maxtradespercross ? countall : 0

var long_row = 0
var short_row = 0 

per_long_row = enablemaxtradespercross ? long_row < maxtradespercross : true 
per_short_row = enablemaxtradespercross ? short_row < maxtradespercross : true


//-----------------------------------------------------------------------------}
//                          Invariable Constants
//-----------------------------------------------------------------------------{
// built in functions to make the script more readable when referencing position conditions // 

FLAT = hedge_mode or dca_mode or pyramiding_mode ? true : strategy.position_size == 0
LONG = strategy.position_size > 0
SHORT = strategy.position_size < 0 
confirmed = barstate.isconfirmed 
entry = strategy.position_avg_price 

_alertfreq = alertfreq == 'Once per bar' ? alert.freq_once_per_bar : alertfreq == 'Once per close' ? alert.freq_once_per_bar_close : alert.freq_all 
 
var lookForExit = false 
var tradeStopPrice = 0.0 
var tradeTargetPrice = 0.0 
var trailingStop = 0.0 
var tradeExitTriggerPrice = 0.0
var tradeStopDistance = 0.0 
var tradeTriggerPrice = 0.0


//-----------------------------------------------------------------------------}
//                          variable calculations
//-----------------------------------------------------------------------------{

atr = ta.atr(atrLen) 

lowestLow = ta.lowest(low, swinglookback) 
highestHigh = ta.highest(high, swinglookback)  

timeFilter = useTimeFilter and not isInSession(timeSession) or not useTimeFilter 
dateFilter = time >= startTime and time <= endTime and useDateFilter or not useDateFilter 

withinTime = timeFilter and dateFilter and (not oktotradonthisday) 
_confirmed = waitforconfirmed ? confirmed : true


//-----------------------------------------------------------------------------}
//                          Condition Build
//-----------------------------------------------------------------------------{
_LongEntry = stepThreeLong and not na(atr) and _confirmed 
_ShortEntry = stepThreeShort and not na(atr) and _confirmed 

validLongEntry = _LongEntry and not na(atr) and useVwapLong and rsilongy and mfilongy and cmlongy and per_long_row and adxlongshort and volumeLong and longha and DIlongy and FLAT and RFLong and _vf_long
validShortEntry = _ShortEntry and not na(atr) and useVwapShort and rsishorty and mfishorty and cmshorty and per_short_row and adxlongshort and volumeShort and shortha and DIshorty and FLAT and RFShort and _vf_short 

//-----------------------------------------------------------------------------}
//                          3 Commas Keys
//-----------------------------------------------------------------------------{

GoLong = threecommasenter 
ExitLong = threecommasexit 
Goshort = threecommasenter_short 
ExitShort = threecommasexit_short 

//-----------------------------------------------------------------------------}
//                          REVERSAL 
//-----------------------------------------------------------------------------{
exit_long = closereverse ? validShortEntry and LONG: false 
exit_short = closereverse ? validLongEntry and SHORT: false 

if exit_long and LONG[1] 
    alert (ExitLong, _alertfreq)
if exit_short and SHORT[1] 
    alert (ExitShort, _alertfreq) 
    
strategy.close(id='Long', when=exit_long, comment='REVERSAL', alert_message=ExitLong) 
strategy.close(id='Short', when=exit_short, comment='REVERSAL', alert_message=ExitShort)

if force_exit_long and LONG[1]
    alert (ExitLong, _alertfreq) 
if force_exit_short and SHORT[1] 
    alert(ExitShort, _alertfreq)
    
strategy.close(id='Long', when=force_exit_long, comment='REVERSAL', alert_message=ExitLong) 
strategy.close(id='Short', when=force_exit_short, comment='REVERSAL', alert_message=ExitShort) 

// Stops and targets cannot calcualte in this period resulting in a broken strategy. Its reccomended to keep that with your own criteria 

condmaxdrawdown = setMaxDrawdown ? maxPercDd: 100 // used to set the max draw down, if used


short_row := validShortEntry ? short_row + 1 : validLongEntry and short_row > 0 ? 0 : short_row 
long_row := validLongEntry ? long_row + 1 : validShortEntry and long_row > 0 ? 0 : long_row 


//-----------------------------------------------------------------------------}
//                          Trialing Stoploss  
//-----------------------------------------------------------------------------{
//Keltner Channel 
KlKllength = 20 
Klmult = trailStopSize 
Kllsrc = close 
Kllexp = true 
BandsStyle = "Average True Range" 
atrKllength = atrLen 
Klesma ( source, KlKllength)=> 
    s = ta.sma (source, KlKllength) 
    e = ta.ema ( source, KlKllength) 
    Kllexp ? e : s
    
Klma = Klesma(Kllsrc, KlKllength) 
Kllrangema = BandsStyle == "True Range" ? ta.tr(true) : BandsStyle == "Average True Range" ? ta.atr(atrKllength): ta.rma(high - low, KlKllength) 
kl_upper = Klma + Kllrangema * Klmult 
kl_lower = Klma - Kllrangema * Klmult


//Bollinger Bands 
lengthBB = 20
srcBB = close 
multBB = trailStopSize 
basisBB = ta.sma(srcBB, lengthBB) 
devBB = multBB * ta.stdev(srcBB, lengthBB) 
upperBB = basisBB + devBB 
lowerBB = basisBB - devBB

//DonChian 
lengthDC = 20 
lowerDC = ta.lowest(lengthDC) 
upperDC = ta.highest(lengthDC) 

    
if LONG and trailStop and lookForExit and confirmed 
    new_atr = atr 
    trailSrcLong = trailSource == 'Close' ? close : trailSource == 'Open' ? open[1] : lowestLow 
    trail = trailSource == 'High/low' or trailSource == 'Close' or trailSource == 'Open' ? trailSrcLong - new_atr * trailStopSize : trailSource == 'Keltner' ? kl_lower : trailSource == 'Ballinger Bands' ? lowerBB :trailSource == 'Donchian Channel' ? lowerDC: trailSrcLong - new_atr * trailStopSize 
    
    needsUpdate = trail > trailingStop 
    trailingStop := needsUpdate ? trail: trailingStop 
    trailingStop 
    

if SHORT and trailStop and lookForExit and confirmed 
    new_atr = atr 
    trailSrcShort = trailSource == 'Close' ? close : trailSource == 'Open' ? open[1] : highestHigh 
    trail = trailSource == 'High/low' or trailSource == 'Close' or trailSource == 'Open' ? trailSrcShort + new_atr * trailStopSize :trailSource == 'Keltner' ? kl_upper : trailSource =='Bollinger Bands' ? upperBB :  trailSource == 'Donchian Channel' ? upperDC: trailSrcShort + new_atr * trailStopSize 
    
    needsUpdate = trail < trailingStop 
    trailingStop := needsUpdate ? trail : trailingStop 
    trailingStop 

//-----------------------------------------------------------------------------}
//                          Calculate Stopss  
//-----------------------------------------------------------------------------{
longStop = lowestLow - atr * RiskM 
shortStop = highestHigh + atr * RiskM 

pips_to_price(val) => 
    val*100*syminfo.mintick


llhhatr_long = close 
llhhatr_short = close 


//-----------------------------------------------------------------------------}
//                          Wich Sroo LOss s  
//-----------------------------------------------------------------------------{
llhhatr_long := atrType == "Source" ? atr_srcLower : lowestLow 
llhhatr_short := atrType == "Source" ? atr_srcUpper : highestHigh 

if typeOfExit == 'Fixed Percent' 
    shortStop := close * (1 + stopPer)
    longStop := close * (1 - StopPerLong) 
    longStop 
else if typeOfExit == 'ATR' 
    longStop := llhhatr_long - atr * RiskM 
    shortStop := llhhatr_short + atr * RiskM 
    shortStop 
else if typeOfExit == 'Keltner' 
    longStop := kl_lower 
    shortStop := kl_upper 
    shortStop 
else if typeOfExit == 'MA #1' 
    longStop := close > out1 ? out1: close * (1 - StopPerLong) 
    shortStop := close < out1 ? out1: close * (1 + stopPer)
    shortStop
else if typeOfExit == 'MA #5' 
    longStop := close > out5 ? out5 : close 
    shortStop := close < out5 ? out5 : close 
else if typeOfExit == 'Bollinger Bands' 
    longStop := lowerBB 
    shortStop := upperBB 
    shortStop 
else if typeOfExit == 'Donchian Channel' 
    longStop := lowerDC 
    shortStop := upperDC 
    shortStop
else if typeOfExit == 'PIPS' 
    longStop := close + pips_to_price(stopPIPSLong) * -1
    shortStop := close + pips_to_price(stopPIPS) * 1 
    shortStop 
else if typeOfExit == 'HH/LL' 
    bought = close[1] 
    sold = close[1] 
    barsbought = ta.barssince(bought) 
    barssold = ta.barssince(sold) 
    stop_level_long = ta.lowest (low, loLen)[1] 
    stop_level_short = ta.highest(high, highLen)[1] 
    shortStop := stop_level_short [barssold] 
    longStop := stop_level_long[barsbought] 
else if typeOfExit == 'Custom' 
    longStop := custom_longStop == 1.0 ? lowestLow - atr * RiskM : custom_longStop 
    shortStop := custom_shortStop == 1.0 ? highestHigh + atr * RiskM : custom_shortStop
    shortStop 
    
//-----------------------------------------------------------------------------}
//                          IF SL > X% then use %  
//-----------------------------------------------------------------------------{
short_maxpercentSL = close * (1 + maxpercent) 
long_maxpercentSL = close * (1 - maxpercent)

short_continue_maxpercent = true 
long_continue_maxpercent = true 

if maxpercent_out == "Use Percentage Instead" and activate_maxpercent 
    shortStop := short_maxpercentSL 
    longStop := long_maxpercentSL 
    short_continue_maxpercent := true 
    long_continue_maxpercent := true 
else 
    short_continue_maxpercent := activate_maxpercent ? short_maxpercentSL > shortStop : true 
    long_continue_maxpercent := activate_maxpercent ? long_maxpercentSL < longStop : true 
    
validShortEntry := short_continue_maxpercent ? validShortEntry: false 
validLongEntry := long_continue_maxpercent ? validLongEntry : false 

//-----------------------------------------------------------------------------}
//                              Leverage   
//-----------------------------------------------------------------------------{
_calculateLeverage(_leverage, _value, _shortSell) =>
    _shortSell ? _value * _leverage / (_leverage - 1 + i_Maintenance / 100 * _leverage) : _leverage * _value / (_leverage + 1 - i_Maintenance / 100 * _leverage)

firstLeverageLongAverage = _calculateLeverage(i_firstLeverage, close, false) 
firstLeverageShortAverage = _calculateLeverage(i_firstLeverage, close, true) 

validLongEntry := i_leverageBlock ? longStop > firstLeverageLongAverage ? validLongEntry: false : validLongEntry 
validShortEntry :=i_leverageBlock ? shortStop < firstLeverageShortAverage ? validShortEntry : false : validShortEntry 


//-----------------------------------------------------------------------------}
//                    Take Profit // r:r calcualtion    
//-----------------------------------------------------------------------------{
longRisk = close - longStop - slbuffer_long 
shortRisk = shortStop - close + slbuffer_short 

longlimit = close + RnRLong * longRisk 
shortlimit = close - RnRShort * shortRisk 


if typeOfTP == 'Fixed Percent' 
    longlimit := close * (1 + TakePerLong) 
    shortlimit := close * (1 - takePer) 
    shortlimit 
else if typeOfTP == 'R:R' 
    longlimit := longlimit 
    shortlimit := shortlimit 
    shortlimit 
else if typeOfTP == 'PIPS' 
    longlimit := close - pips_to_price(takePIPSLong) * -1
    shortlimit := close - pips_to_price(takePIPS) * 1
    shortlimit
else if typeOfTP == 'Custom' 
    longlimit := custom_longTP == 1.0 ? l : custom_longTP
    shortlimit := custom_shortTP == 1.0 ? l : custom_shortTP 
    shortlimit

//-----------------------------------------------------------------------------}
//                    -> Risk MANAGEMENT     
//-----------------------------------------------------------------------------{
krp = strategy.wintrades / strategy.closedtrades 
krw = strategy.grossprofit / strategy.wintrades 
krl = strategy.grossloss  / strategy.losstrades
kr = math. round ( (krp - (1 - krp) / (krw / krl)) * 100 / 100,4) 

qty = _net_qty 
qtyLong = _net_qty 
qtyShort = _net_qty 
mm = strategy.equity * (risk / 100) 
if marginCal == 'Kelly Ratio' 
    qty := strategy.equity 
    if kr > 0 and qty > 0 
        // qty := g((strategy.equity*(kr*10)) * leverage / open 
        //qty := g(strategy. equity * leverage / open / kr 
        //qty := g(((strategy.equity * (krÃ—10) ) / close) * leverage / open * 100 
        qty := g(((strategy.equity) * leverage / open) * ( (kr*10) / 100), 4) 
        
    mm := strategy.equity * (kr*10) 
    
    qtyLong := qty 
    qtyShort := qty
    qty

else if marginCal == 'Dynamic Algo' 
    risk_source = _risk_source_input == 'close' ? close :_risk_source_input == "volume" ? volume :_risk_source_input == "MA 5" ? ta.sma (close, 5) :_risk_source_input == "MA 25" ? ta.sma (close, 25) :_risk_source_input == 'MACD' ? ta.sma(close,5)-ta.sma(close, 25) :_risk_source_input == 'volume MA' ? ta.sma(volume, 25) : _risk_source_input == 'ATR' ? ta.rma(ta.tr(true), 14) : _risk_source_input == 'ADX' ? _adxline : close 
        
    risk_highest = ta.highest(risk_source, 100) 
    risk_lowest = ta.lowest (risk_source, 100) 
    risk_third = ((risk_highest - risk_lowest) / 3 ) 
    risk_zone_1 = risk_lowest + risk_third 
    risk_zone_2 = risk_highest - risk_third 
    qty := qty
    if risk_source < risk_zone_1 
        qty := qty*_risk_da_qty_1 
        qtyLong := qty 
        qtyShort := qty 
        qty 
    else if risk_source >= risk_zone_1 and risk_source <= risk_zone_2 
        qty := qty*_risk_da_qty_2 
        qtyLong := qty 
        qtyShort := qty 
        qty
    else
        qty := qty * _risk_da_qty_3  // Adjust this line based on your intended logic for values greater than risk_zone_2
        qtyLong := qty 
        qtyShort := qty 


// TP/SL trail backtest system ---------------------------------------------
TakeProfit = input.float(2.3, title='Take Profit', minval=0.1, step=0.1, group='Take Profit / Stop Loss')
StopLoss = input.float(2, title='Stop loss', minval=0.1, step=0.1, group='Take Profit / Stop Loss')

//BACKTESTING inputs -----------
showLines = input(true, "Show TP/SL lines", group='BACKTEST')
ExtendTrailLines = input.int(5, 'Extend trail lines for bars:', minval=1, group='BACKTEST')

useTrailSL = input(false, "Use trail", group='Trail system', tooltip = "Main parameter to activate trail function in general (SL by default, TP as optional)")
TrailSteps = input.int(3, "Trail SL steps (2-3)", minval = 2, maxval = 3, group='Trail system', tooltip = "This will alow you to choose how many steps you want for trail SL/TP before main take profit is hit. For example 2 means that first trail SL will be on 50% of your main TP, 3 on each 33% of your main TP as one trail. On each step that is passed strategy will close 1/3 of your position if you activate trail TP to.")
LadderTrail = input(false, "Ladder trail", group='Trail system', tooltip = "Use Trail must be activated, while this function will set SL one level lower after the each level is reached. For example if step 1 is reached SL will be on break even, if step 2 is reached SL will be on step 1 and so on...")
TrailSLContinue = input(false, "Continue with trail SL without main TP", group='Trail system', tooltip = "Alert to close the position will be sent once that trail SL level is broken. If you are using third party app via webhook pay attention to disable TP there to.")
useTrailTP = input(false, "Trail TP", inline = "trailTP", group='Trail system', tooltip = "If this option is activated it will close 1/3 of the position on each trail steps. The last 1/3 will be closed according to trail settings")
useClosePriceForTrailTP = input(false, "Use candles close price to calc trail SL", group='Trail system', tooltip = "This option will use candle close price that is always above trail step to calculate trail SL, which means in most scenarios will set higher SL step then initially set.")
useWicksSL = input(false, "Use wicks to calc and activate trail SL level (Work with ladder)", group = "Trail system", tooltip = "This option will consider candles wick as price that is over trail level if candle is not closed above the trail level but just wick is")
usePBsecure = input(false, "Use secure for pullback after trail level is reached", group='Trail system', tooltip = "This will consider to close the next position size if price is get back above the trail level again")
PBThreshold = input.float(50, "Pullback threshold %", group='Trail system', step = 1, minval = 1, tooltip = "This threshold is between two trail levels")

//ALERTS Messages -----------------------
i_alert_txt_entry_long = input.text_area(defval = "", title = "Long Entry Message", group = "Alerts")
i_alert_txt_entry_short = input.text_area(defval = "", title = "Short Entry Message", group = "Alerts")
i_alert_txt_tp_long = input.text_area(defval = "", title = "Long Market Close Message", group = "Alerts")
i_alert_txt_tp_short = input.text_area(defval = "", title = "Short Market Close Message", group = "Alerts")

i_alert_txt_trailTP_long = input.text_area(defval = "", title = "Long trail TP 1 (close 33% of position) Message", group = "Alerts")
i_alert_txt_trailTP2_long = input.text_area(defval = "", title = "Long trail TP 2 (close 50% of position) Message", group = "Alerts")

i_alert_txt_trailTP_short = input.text_area(defval = "", title = "Short trail TP 1 (close 33% of position) Message", group = "Alerts")
i_alert_txt_trailTP2_short = input.text_area(defval = "", title = "Short trail TP 2 (close 50% of position) Message", group = "Alerts")


// BACKTEST ====================
var bool longCond = na
var bool shortCond = na

// Here is your input trigger conditions for long/short
longCond := validLongEntry
shortCond := validShortEntry

var float tplLevel = na
var float tpsLevel = na
var float sllLevel = na
var float slsLevel = na
var TrailTPstep = 0
var PlotTrailPos = false
var TrailSignal = false
var GoToPosL = false
var GoToPosS = false

// Backtest Long ===================
tplLevel := na
sllLevel := na
if longTrades
    if longCond
        if strategy.position_size < 0
            strategy.cancel_all()
            strategy.close_all(comment = "Close short", alert_message = i_alert_txt_tp_short)
            GoToPosL := true
            
        if strategy.opentrades == 0
            strategy.entry('Long', strategy.long, alert_message = i_alert_txt_entry_long)
            TrailSignal := false
            TrailTPstep := 0
            PlotTrailPos := false
            
    if strategy.position_size > 0
        strategy.exit('TP_L', from_entry = 'Long',alert_message = i_alert_txt_tp_long, comment_loss = "SL long" , comment_profit = "TP Long", limit = TrailSLContinue ? na : strategy.position_avg_price * (1 + (TakeProfit/100)), stop = strategy.position_avg_price * (1 - (StopLoss / 100)))
        tplLevel := strategy.position_avg_price * (1 + (TakeProfit/100))
        sllLevel := strategy.position_avg_price * (1 - (StopLoss / 100))
if GoToPosL and strategy.position_size > 0
    GoToPosL := false
//if GoToPosL and (strategy.opentrades == 0 or strategy.position_size < 0)
//    GoToPosL := false
//    strategy.entry('Long', strategy.long, alert_message = i_alert_txt_entry_long)
//    TrailSignal := false
//    TrailTPstep := 0
//    PlotTrailPos := false

// Backtest Short ===================
tpsLevel := na
slsLevel := na

if shortTrades
    if shortCond
        if strategy.position_size > 0
            strategy.cancel_all()
            strategy.close_all(comment = "Close long", alert_message = i_alert_txt_tp_long)
            GoToPosS := true
            
        if strategy.opentrades == 0
            strategy.entry('Short', strategy.short, alert_message = i_alert_txt_entry_short)
            TrailSignal := false
            TrailTPstep := 0
            PlotTrailPos := false
            
    if strategy.position_size < 0
        strategy.exit('TP_S', from_entry = 'Short', alert_message = i_alert_txt_tp_short,comment_loss = "SL Short" , comment_profit = "TP Short", limit = TrailSLContinue ? na : strategy.position_avg_price * (1 - (TakeProfit/100)), stop = strategy.position_avg_price * (1 + (StopLoss / 100)))
        tpsLevel := strategy.position_avg_price * (1 - (TakeProfit/100))
        slsLevel := strategy.position_avg_price * (1 + (StopLoss / 100))
if GoToPosS and strategy.position_size < 0
    GoToPosS := false
//if GoToPosS and (strategy.opentrades == 0 or strategy.position_size > 0)
//    GoToPosS := false
//    strategy.entry('Short', strategy.short, alert_message = i_alert_txt_entry_short)
//    TrailSignal := false
//    TrailTPstep := 0
//    PlotTrailPos := false

//Price plots ----------------------
plot(strategy.position_size > 0 and showLines ? tplLevel : na, title='Long TP ', style=plot.style_cross, color=color.new(color.lime, 0), linewidth=1)
plot(strategy.position_size > 0 and showLines and TrailSignal == false ? sllLevel : na, title='Long main SL ', style=plot.style_cross, color=color.blue, linewidth=1)
plot(strategy.position_size < 0 and showLines ? tpsLevel : na, title='Short TP ', style=plot.style_cross, color=color.new(#ff3b3b, 0), linewidth=1)
plot(strategy.position_size < 0 and showLines and TrailSignal == false ? slsLevel : na, title='Short main SL ', style=plot.style_cross, color=color.blue, linewidth=1)

//plot 
plotshape(longCond and (strategy.opentrades == 0 or strategy.position_size < 0), title='Long', style=shape.triangleup, location=location.belowbar, color=color.new(color.blue, 0), size=size.small, text='', textcolor=color.new(color.white, 0))
plotshape(shortCond and (strategy.opentrades == 0 or strategy.position_size > 0), title='Short', style=shape.triangledown, location=location.abovebar, color=color.new(color.red, 0), size=size.small, text='', textcolor=color.new(color.white, 0))


// Trail SL/TP =========================
var float TrailPricePart = 0.
var float TrailSLPrice = 0.
var float TrailSLLastPrice = 0.
var line TrailLine = na
WickSLcalc = false
PullbackSecure = false
var float SecureTrailPrice = 0.

//Long
if useTrailSL and strategy.position_size > 0
    if TrailSteps == 2
        TrailPricePart := (strategy.position_avg_price * (1 + ((TakeProfit/100)/2))) - strategy.position_avg_price
        if TrailSignal == false
            TrailSLPrice := strategy.position_avg_price * (1 + ((TakeProfit/100)/2))
        if PlotTrailPos == false
            if showLines
                line.new(bar_index,TrailSLPrice,bar_index+ExtendTrailLines,TrailSLPrice,color = color.green,width = 1)
            PlotTrailPos := true
    if TrailSteps == 3
        TrailPricePart := (strategy.position_avg_price * (1 + ((TakeProfit/100)/3))) - strategy.position_avg_price
        if TrailSignal == false
            TrailSLPrice := strategy.position_avg_price * (1 + ((TakeProfit/100)/3))
        if PlotTrailPos == false
            if showLines
                line.new(bar_index,TrailSLPrice,bar_index+ExtendTrailLines,TrailSLPrice,color = color.green,width = 1)
                line.new(bar_index,TrailSLPrice+TrailPricePart,bar_index+ExtendTrailLines,TrailSLPrice+TrailPricePart,color = color.green,width = 1)
            PlotTrailPos := true
    
    if close > (high - TrailPricePart)
        WickSLcalc := true

    if TrailSignal and usePBsecure
        if low < (SecureTrailPrice - (((SecureTrailPrice - (SecureTrailPrice - TrailPricePart))/100) * PBThreshold))
            PullbackSecure := true
    if PullbackSecure and close >= SecureTrailPrice and usePBsecure
        strategy.close("Long", comment = "Secure TP long", alert_message = i_alert_txt_tp_long)
        

    if useWicksSL and WickSLcalc and LadderTrail ? high > TrailSLPrice : close > TrailSLPrice
        TrailSignal := true
    
    if useWicksSL and WickSLcalc and LadderTrail ? high > TrailSLPrice : close > TrailSLPrice
        if LadderTrail
            if useClosePriceForTrailTP
                TrailSLLastPrice := useWicksSL ? high - TrailPricePart : close - TrailPricePart
            else
                TrailSLLastPrice := useWicksSL ? high - TrailPricePart : TrailSLPrice - TrailPricePart
        else
            TrailSLLastPrice := TrailSLPrice
        
        strategy.cancel_all()
        if useTrailTP
            if TrailTPstep == 0
                strategy.close("Long", comment = "trail TP long", qty_percent = 33, alert_message = i_alert_txt_trailTP_long)
                SecureTrailPrice := TrailSLPrice
                TrailTPstep := 1
            else
                if TrailTPstep == 1 and TrailSteps == 3
                    strategy.close("Long", comment = "trail TP long", qty_percent = 50, alert_message = i_alert_txt_trailTP2_long)
                    SecureTrailPrice := TrailSLPrice
                    TrailTPstep := 2
        
        TrailSLPrice := TrailSLPrice + TrailPricePart
        strategy.exit('TSL_L', from_entry = 'Long', alert_message = i_alert_txt_tp_long, comment_profit = "TP Long", comment_loss = "trail SL long", limit = TrailSLContinue ? na : strategy.position_avg_price * (1 + (TakeProfit/100)), stop = TrailSLLastPrice)

plot(strategy.position_size > 0 and TrailSignal and showLines ? TrailSLLastPrice : na, title='Long trail SL ', style=plot.style_cross, color=color.new(color.blue, 0), linewidth=1)

//Short
if useTrailSL and strategy.position_size < 0
    if TrailSteps == 2
        TrailPricePart := strategy.position_avg_price - (strategy.position_avg_price * (1 - ((TakeProfit/100)/2)))
        if TrailSignal == false
            TrailSLPrice := strategy.position_avg_price * (1 - ((TakeProfit/100)/2))
        if PlotTrailPos == false
            if showLines
                line.new(bar_index,TrailSLPrice,bar_index+ExtendTrailLines,TrailSLPrice,color = color.red,width = 1)
            PlotTrailPos := true
    if TrailSteps == 3
        TrailPricePart := strategy.position_avg_price - (strategy.position_avg_price * (1 - ((TakeProfit/100)/3)))
        if TrailSignal == false
            TrailSLPrice := strategy.position_avg_price * (1 - ((TakeProfit/100)/3))
        if PlotTrailPos == false
            if showLines
                line.new(bar_index,TrailSLPrice,bar_index+ExtendTrailLines,TrailSLPrice,color = color.red,width = 1)
                line.new(bar_index,TrailSLPrice-TrailPricePart,bar_index+ExtendTrailLines,TrailSLPrice-TrailPricePart,color = color.red,width = 1)
            PlotTrailPos := true

    if close < (low + TrailPricePart)
        WickSLcalc := true

    if TrailSignal and usePBsecure
        if high > (SecureTrailPrice + ((((SecureTrailPrice + TrailPricePart) - SecureTrailPrice)/100) * PBThreshold))
            PullbackSecure := true
    if PullbackSecure and close <= SecureTrailPrice and usePBsecure
        strategy.close("Short", comment = "Secure TP short", alert_message = i_alert_txt_tp_short)
        
    if useWicksSL and WickSLcalc and LadderTrail ? low < TrailSLPrice : close < TrailSLPrice
        TrailSignal := true
    
    if useWicksSL and WickSLcalc and LadderTrail ? low < TrailSLPrice : close < TrailSLPrice
        if LadderTrail
            if useClosePriceForTrailTP
                TrailSLLastPrice := useWicksSL ? low + TrailPricePart : close + TrailPricePart
            else
                TrailSLLastPrice := useWicksSL ? low + TrailPricePart : TrailSLPrice + TrailPricePart
        else
            TrailSLLastPrice := TrailSLPrice
        
        
        strategy.cancel_all()
        if useTrailTP
            if TrailTPstep == 0
                strategy.close("Short", comment = "trail TP short", qty_percent = 33, alert_message = i_alert_txt_trailTP_short)
                SecureTrailPrice := TrailSLPrice
                TrailTPstep := 1
            else
                if TrailTPstep == 1 and TrailSteps == 3
                    strategy.close("Short", comment = "trail TP short", qty_percent = 50, alert_message = i_alert_txt_trailTP2_short)
                    SecureTrailPrice := TrailSLPrice
                    TrailTPstep := 2
        
        TrailSLPrice := TrailSLPrice - TrailPricePart
        strategy.exit('TSL_S', from_entry = 'Short', alert_message = i_alert_txt_tp_short, comment_profit = "TP Short", comment_loss = "trail SL short", limit = TrailSLContinue ? na : strategy.position_avg_price * (1 - (TakeProfit/100)), stop = TrailSLLastPrice)

plot(strategy.position_size < 0 and TrailSignal and showLines ? TrailSLLastPrice : na, title='Short trail SL ', style=plot.style_cross, color=color.new(color.blue, 0), linewidth=1)

